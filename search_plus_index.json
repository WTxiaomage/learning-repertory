{"./":{"url":"./","title":"首页","keywords":"","body":"learning-repository 这是一个学习仓库，里面记录自己的学习经验和想法。 为了提升阅读体验，已将本库部署为在线小册，点击阅读 一、初心不改 一直以来都想建一个自己学习的经验和想法的笔记，但是很多时候疲于奔命，很少停下来反思，最近因为发现自己曾经学过的东西有很多好的想法都忘记了，痛定思痛，决定从现在开始慢慢累积，把自己学到的点点滴滴都记录下来，希望看着这个仓库越来越繁荣。 二、仓库目录 目录 详情 Git Git基本命令 React React相关知识 Vue Vue相关知识 三、学习环境 推荐一个网站，慕课网 四、赞助不断 你的鼓励将是我的动力！ 如果觉得对您有帮助，欢迎star和clone 读后有收获可以请作者喝咖啡 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-27 19:33:31 "},"src/Git/":{"url":"src/Git/","title":"Git 基本命令 ✔","keywords":"","body":"Git 基本命令 创建库 git init 初始化仓库 git config user.name wangtao 设置用户名 git config user.email 331871902@qq.com 设置邮箱 git config --global user.name wangtao 设置全局用户名（一般只设置一次） git config --global user.email 331871902@qq.com 设置全局邮箱（一般只设置一次） git remote add 别名 仓库地址 例如： git remote add origin 仓库地址 git remote add origin_ssh 仓库地址 以上几步做完会有.git 文件夹，并且内部有 config 文件，里面有所有相关的信息 运用库 添加文件 git status 查看库的状态 git add filename 添加指定文件暂存区 git add . 添加所有文件到暂存区(不包括删除文件) git add -A 添加所有文件到暂存区(包括删除文件) git commit -m \"提交注释\" 提交到本地库 删除文件 先在文件管理器中删除文件 git rm filename 删除文件 git commit -m \"删除注释\" 删除到本地库 版本回退 git reset --soft 参数 移动本地库 HEAD 指针 git reset --mixed 参数 移动本地库、暂存区 HEAD 指针 git reset --hard 参数 移动本地库、暂存区、工作区 HEAD 指针 分支管理 git branch test(分支名) 创建新分支 git checkout test 切换分支 git branch 查看所有分支 git checkout master 切换主分支 git merge test 合并分支 git branch -D test 删除分支 Bug 分支管理 git stash 储藏工作现场 git stash list 查看储藏列表 git stash pop 恢复储藏 与 GitHub 交互 git push 仓库地址别名 分支名 git push origin master 推送本地库到远程库 git fetch 仓库地址别名 分支名 git fetch origin master 抓取远程库到本地库 git merge 仓库地址别名 分支名 git merge origin master 合并远程库到本地库 git pull 仓库地址别名 分支名 git pull origin master 抓取+合并远程库到本地库 git clone 仓库地址 git clone https://github.com/WTxiaomage/learning-repository.git 下载远程库到本地库 设置本地 dev 分支与远程 dev 分支的追踪关系 在 dev 分支下执行 git branch --set-upstream-to=origin/dev 项目中开发 通常去一家公司，需要 down 项目到本地，而我们通常将 dev 分支作为开发分支，clone 到本地后，需创建自己的分支开发 第一种方法(麻烦)： git clone 仓库地址 (克隆下来只有 master 分支) cd 本地文件夹名 (进入本地仓库) git branch dev (创建 dev 分支) git checkout dev (切换到 dev 分支) git pull 远程地址 dev (拉取远程 dev 分支) 这种方法较麻烦，本地有两个分支 第二种方法(推荐) git clone -b dev https://github.com/WTxiaomage/learning-repository.git 这种方法只会 clone 远程仓库的 dev 分支到本地，本地只存在我们经常用的分支 总结 这只是个人在项目开发过程中经常用到的命令集合，方便快速记忆和查阅，如果想系统学习 git，推荐《廖雪峰的 Git 教程》 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-27 19:33:31 "},"src/React/":{"url":"src/React/","title":"React ✔","keywords":"","body":"React 目录 目录 React基本认识 React组件化编程 React脚手架创建项目 React-Router Redux 总结 参考文档：React-Router 中文文档 参考文档：react-admin完整项目 参考文档：Redux 中文文档 参考文档：一个 react + redux 的完整项目 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-27 19:33:31 "},"src/React/01_react_base.html":{"url":"src/React/01_react_base.html","title":"React 基础","keywords":"","body":"1. React 基础 目录 1.1 React 基本认识 1.2 React 基本使用 1.3 JSX 的理解和使用 1.4 模块与模块化, 组件与组件化的理解 1.5 基础 DEMO 1.1 React 的基本认识 Facebook 开源的一个 js 库 一个用来动态构建用户界面的 js 库 React 的特点 Declarative(声明式编码) Component-Based(组件化编码) Learn Once, Write Anywhere(支持客户端与服务器渲染) 高效 单向数据流 React 高效的原因 虚拟 DOM(virtual), 不总是直接操作 DOM(批量更新, 减少更新的次数) 高效的 DOM Diff 算法, 最小化页面重绘(减小页面更新的区域) 1.2 React 的基本使用 导入相关 js 库文件(react.js, react-dom.js, babel.min.js) react.js: React 的核心库 react-dom.js: 提供操作 DOM 的 React 扩展库 babel.min.js: 解析 JSX 语法代码转为纯 JS 语法代码的库 在 HTML 文件中编码: var aa = 123 var bb = 'test' ReactDOM.render({aa}, containerDOM) 1.3 JSX 的理解和使用 理解 全称: JavaScript XML react 定义的一种类似于 XML 的 JS 扩展语法: XML+JS 作用: 用来创建 react 虚拟 DOM(元素)对象 编码相关 js 中直接可以套标签, 但标签要套 js 需要放在{}中 在解析显示 js 数组时, 会自动遍历显示 把数据的数组转换为标签的数组: var liArr = dataArr.map(function(item, index){ return {item} }) 在 JSX 中 map 函数用的非常多，经常用它来将数组转化为 ReactDOM 数组,对数组的遍历每一项要加 key 注意: 标签必须有结束 标签的 class 属性必须改为 className 属性 标签的 style 属性值必须为:双大括号 className 要展现多个类名,前者是定死的类名，后者写活的，可以用于写动画效果 {formatName(user)} {formatName(user)} 1.4 几个重要概念理解 1. 模块与组件 模块: 理解: 向外提供特定功能的 js 程序, 一般一个功能就是一个 js 文件 为什么: js 代码更多更复杂 作用: 复用 js, 简化 js 的编写, 提高 js 运行效率 组件: 理解: 用来实现特定功能效果的代码集合(html/css/js) 为什么: 一个界面的功能太复杂了 作用: 复用编码, 简化项目界面编码, 提高运行效率 2. 模块化与组件化 模块化: 当应用的 js 都以模块来编写的, 这个应用就是一个模块化的应用 组件化: 当应用是以多组件的方式实现功能, 这上应用就是一个组件化的应用 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-29 16:00:01 "},"src/React/02_react_component_programming.html":{"url":"src/React/02_react_component_programming.html","title":"React 深入","keywords":"","body":"2. React 组件化编程 目录 2.1 组件的理解与使用 2.2 组件的 3 大属性: state 2.3 组件的 3 大属性: props 2.4 组件的 3 大属性: refs 2.5 组件中的事件处理 2.6 组件的组合使用 2.7 组件收集表单数据 2.8 组件的生命周期（重点） 2.9 虚拟 DOM 与 DOM diff 算法 2.10 命令式编程与声明式编程 2.11 基础 DEMO 2.1 基本理解和使用 自定义的标签: 组件类(函数)/标签 创建组件类//方式1: 无状态函数(简单组件, 推荐使用) function MyComponent1(props) { return 自定义组件标题11111 } //方式2: ES6类语法(复杂组件, 推荐使用) class MyComponent3 extends React.Component { render () { return 自定义组件标题33333 } } 渲染组件标签 ReactDOM.render(, cotainerElement) 组件名必须首字母大写 虚拟 DOM 元素只能有一个根元素 虚拟 DOM 元素必须有结束标签 ReactDOM.render()渲染组件标签的基本流程 React 内部会创建组件实例对象/调用组件函数 得到虚拟 DOM 对象 将虚拟 DOM 并解析为真实 DOM，插入到指定的页面元素内部 2.3 state 组件被称为\"状态机\", 页面的显示是根据组件的 state 属性的数据来显示 初始化指定:constructor() { super() this.state = { stateName1 : stateValue1, stateName2 : stateValue2 } } 读取显示:this.state.stateName1 更新状态-->更新界面 : this.setState({stateName1 : newValue}) 2.3 props 所有组件标签的属性的集合对象 给标签指定属性, 保存外部数据(可能是一个 function) 在组件内部读取属性:this.props.propertyName 作用: 从目标组件外部向组件内部传递数据 对 props 中的属性值进行类型限制和必要性限制Person.propTypes = { name: React.PropTypes.string.isRequired, age: React.PropTypes.number.isRequired } 扩展属性: 将对象的所有属性通过 props 传递 默认属性值Person.defaultProps = { name: 'Mary' } 组件类的构造函数constructor (props) { super(props) console.log(props) // 查看所有属性 } 问题: 请区别一下组件的 props 和 state 属性 state: 组件自身内部可变化的数据 props: 从组件外部向组件内部传递数据, 组件内部只读不修改 2.4 refs 组件内包含 ref 属性的标签元素的集合对象 给操作目标标签指定 ref 属性, 打一个标识 在组件内部获得标签对象: this.refs.msgInput this.msgInput = input}/> this.msgInput 两种运用 refs 的方法，官方建议用第二种，其实第一种较简单 尽量不要用 refs，因为它实质上在操作 DOM，而我们 React 是尽量不操作 DOM 作用: 找到组件内部的真实 dom 元素对象, 进而操作它 2.5 组件中的事件处理 给标签添加属性:onXxx={this.eventHandler} onXxx={(a)=>this.eventHandler(a)} 前者不能传参，后者能传参 在组件中添加事件处理方法eventHandler(event) { } eventHandler=(event)=> { } 前者需要绑定 this,后者不需要绑定 this 使自定义方法中的 this 为组件对象 在 constructor()中 bind(this) 使用箭头函数定义方法(ES6 模块化编码时才能使用) 事件监听 绑定事件监听 事件名 回调函数 触发事件 用户对对应的界面做对应的操作 编码 2.6 组件的组合使用 拆分组件: 拆分界面,抽取组件 实现静态组件: 使用组件实现静态页面效果 实现动态组件 动态显示初始化数据 交互功能(从绑定事件监听开始) 2.7 组件收集表单数据 受控组件 非受控组件 实时保存 value 值到 state 中为受控组件 2.8 组件的生命周期 组件的三个生命周期状态: Mount：插入真实 DOM Update：被重新渲染 Unmount：被移出真实 DOM 生命周期流程: 挂载阶段:ReactDOM.render(, containerDom) constructor() componentWillMount() : 将要插入回调 render() : 用于插入虚拟 DOM 回调 componentDidMount() : 已经插入回调 更新阶段:this.setState({}) componentWillReceiveProps(nextProps): 接收父组件新的属性 shouldComponentUpdate(nextProps, nextState) 是否组件更新（通常在此处子组件是否需要重新渲染） componentWillUpdate(nextProps, nextState) : 将要更新回调 render() : 更新(重新渲染) componentDidUpdate(prevProps, prevState, snapshot) : 已经更新回调 卸载阶段:ReactDOM.unmountComponentAtNode(div) componentWillUnmount() : 组件将要被移除回调 父子组件生命周期例子 16.4 新版生命周期 在 16.4 版本里面有 3 个 will 相关的生命周期被static getDerivedStateFromProps(props, state)代替，减少生命周期的滥用 父子组件生命周期例子 getSnapshotBeforeUpdate(prevProps, prevState)不常用 官方组件生命周期函数 官方组件生命周期图 2.9 虚拟 DOM 与 DOM diff 算法 虚拟 DOM 是什么? 一个虚拟 DOM(元素)是一个一般的 js 对象, 准确的说是一个对象树(倒立的) 虚拟 DOM 保存了真实 DOM 的层次关系和一些基本属性，与真实 DOM 一一对应 如果只是更新虚拟 DOM, 页面是不会重绘的 Virtual DOM 算法的基本步骤 用 JS 对象树表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把差异应用到真实 DOM 树上，视图就更新了 进一步理解 Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。 可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。 2.10 命令式编程与声明式编程 声明式编程 只关注做什么, 而不关注怎么做(流程), 类似于填空题 命令式编程 要关注做什么和怎么做(流程), 类似于问答题 var arr = [1, 3, 5, 7] // 需求: 得到一个新的数组, 数组中每个元素都比 arr 中对应的元素大 10: [11, 13, 15, 17] // 命令式编程 var arr2 = [] for(var i =0;i Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-27 19:33:31 "},"src/React/03_react_practice.html":{"url":"src/React/03_react_practice.html","title":"React 脚手架创建项目","keywords":"","body":"3 使用 create-react-app 创建 react 应用 目录 3.1 react 脚手架 3.2 创建项目并启动 3.3 react 脚手架项目结构 3.4 使用脚手架开发的项目的特点 3.5 组件化编写项目的流程 3.6 app1: 实现一个评论管理功能 3.7 组件间通信总结 3.8 ES6 新语法总结 3.9 项目打包运行 3.1 react 脚手架 xxx 脚手架: 用来帮助程序员快速创建一个基于 xxx 库的模板项目 包含了所有需要的配置 指定好了所有的依赖 可以直接安装/编译/运行一个简单效果 react 提供了一个专门用于创建 react 项目的脚手架库: create-react-app 项目的整体技术架构为: react + webpack + es6 + babel + eslint 3.2 创建项目并启动 npm install -g create-react-app create-react-app react-app cd react-app npm start 3.3 react 脚手架项目结构 |--node_modules---第三方依赖模块文件夹 |--public |-- index.html-----------------主页面 |--scripts |-- build.js-------------------build打包引用配置 |--start.js-------------------start运行引用配置 |--src------------源码文件夹 |--components-----------------react组件 |--index.js-------------------应用入口js |--.gitignore------git版本管制忽略的配置 |--package.json----应用包配置文件 |--README.md-------应用描述说明的readme文件 3.4 使用脚手架开发的项目的特点 模块化: js 是一个一个模块编写的 组件化: 界面是由多个组件组合编写实现的 工程化: 实现了自动构建/运行/打包的项目 3.5 组件化编写项目的流程 拆分组件 实现静态组件--->静态页面 实现动态组件 动态显示初始化数据 交互 3.6 app1: 实现一个评论管理功能 demo1-react-comment 地址 拆分组件: 应用组件: app 添加评论组件: comment-add 评论项组件: comment-item 评论列表组件: comment-list 确定组件的 state 和 props: app: state: comments/array comment-add state: username/string, content/string props: add/func comment-list props: comments/array, delete/func comment-item props: comment/object, delete/func, index/number 编写静态组件 拆分页面 拆分 css 实现动态组件 动态展示初始化数据 初始化状态数据 传递属性数据 响应用户操作, 更新组件界面 绑定事件监听, 并处理 更新 state 3.7 组件间通信总结 方式一: 通过 props 传递 共同的数据放在父组件上, 特有的数据放在自己组件内部(state) 一般数据-->父组件传递数据给子组件-->子组件读取数据 函数数据-->子组件传递数据给父组件-->子组件调用函数 问题: 多层传递属性麻烦, 兄弟组件通信不方便 方式二: 使用消息订阅(subscribe)-发布(publish)机制: 自定义事件机制 工具库: PubSubJS 下载: npm install pubsub-js --save 使用: import PubSub from 'pubsub-js' //引入 PubSub.subscribe('delete', function(msg, data){ }); //订阅 PubSub.publish('delete', data) //发布消息 优点: 可以支持任意关系组件之间的通信 方式三: Redux 事件监听理解 DOM 事件 绑定事件监听 - 事件名(类型): 只有有限的几个, 不能随便写 - 回调函数 用户操作触发事件(event) - 事件名(类型) - 数据 自定义事件 绑定事件监听 - 事件名(类型): 任意 - 回调函数: 通过形参接收数据, 在函数体处理事件 触发事件(编码) - 事件名(类型): 与绑定的事件监听的事件名一致 - 数据: 会自动传递给回调函数 3.8 ES6 新语法总结 定义变量/常量: const/let 解构赋值: let {a, b} = this.props import {aa} from 'xxx' 对象的简洁表达: {a, b} 箭头函数: 组件的自定义方法: xxx = () => {} map/filter的回调方法: (item, index) => {} 优点: * 简洁 * 没有自己的this,使用引用this查找的是外部this 扩展运算符: ... 拆解对象: const MyProps = {}, 类: class/extends/constructor/super ES6模块化: export default | import 3.9 项目打包运行 npm run build //生成打包文件 npm install -g serve //全局下载服务器包 serve build //通过服务器命令运行打包项目 访问: http://localhost:5000 //浏览器访问 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-27 19:33:31 "},"src/React/04_react-router.html":{"url":"src/React/04_react-router.html","title":"React-Router","keywords":"","body":"4 React-Router 目录 4.1 react-router 理解 4.2 redux 相关 API 4.3 react-router 的学习资源 4.4 相关 API 4.5 react-router 的基本使用 4.6 向路由组件传递请求参数 4.7 优化 Link 组件 4.1 react-router 理解 React 的一个插件库 专门用来实现一个 SPA 应用 基于 React 的项目基本都会用到此库 4.2 几个重要问题 SPA 应用 单页 Web 应用（single page web application，SPA） 整个应用只有一个完整的页面 点击页面中的链接不会刷新页面, 本身也不会向服务器发请求 当点击链接时, 只会做页面的局部更新 数据都需要通过 ajax 请求获取, 并在前端异步展现 路由 什么是路由? 一个路由就是一个映射关系(key:value) key 为路由路径, value 可能是 function/component 路由分类 后台路由: node 服务器端路由, value 是 function, 用来处理客户端提交的请求并返回一个响应数据 前台路由: 浏览器端路由, value 是 component, 当请求的是路由 path 时, 浏览器端前没有发送 http 请求, 但界面会更新显示对应的组件 后台路由 注册路由: router.get(path, function(req, res)) 当 node 接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据 前端路由 注册路由: 当浏览器的 hash 变为#about 时, 当前路由组件就会变为 About 组件 关于 url 中的 理解# '#'代表网页中的一个位置。其右面的字符，就是该位置的标识符 改变#不触发网页重载 改变#会改变浏览器的访问历史 操作# window.location.hash 读取#值 window.onhashchange = func 监听 hash 改变 学习资源: 阮一峰教程 url_hash 4.3 react-router 的学习资源 github 主页: https://github.com/ReactTraining/react-router 官网教程: https://github.com/reactjs/react-router-tutorial 4.4 相关 API react-router 中的相关组件: router: 路由器组件, 用来包含各个路由组件 route: 路由组件, 注册路由 IndexRoute: 默认子路由组件 hashHistory: 路由的切换由 URL 的 hash 变化决定，即 URL 的#部分发生变化 Link: 路由链接组件 router: 路由器组件 属性: history={hashHistory} 用来监听浏览器地址栏的变化, 并将 URL 解析成一个地址对象，供 React Router 匹配 子组件: route route: 路由组件 属性 1:path=\"/xxx\" 属性 2: component={Xxx} 根路由组件: path=\"/\"的组件, 一般为 App 子路由组件: 子配置的组件 IndexRoute: 默认路由 当父路由被请求时, 默认就会请求此路由组件 hashHistory 用于 router 组件的 history 属性 作用: 为地址 url 生成?\\_k=hash, 用于内部保存对应的 state Link: 路由链接 属性 1: to=\"/xxx\" 属性 2: activeClassName=\"active\" 4.5 react-router 的基本使用 下载 npm install react-router --save 定义各个路由组件 1. About.js import React from 'react' function About() { return About组件内容 } export default About 2. Home.js import React from 'react' function Home() { return Home组件内容2 } export default Home 3. Repos.js import React, {Component} from 'react' export default class Repos extends Component { render() { return ( Repos组件 ) } } 4. App.js import React, {Component} from 'react' import {Link} from 'react-router' export default class App extends Component { render() { return ( Hello, React Router! About2 Repos2 {this.props.children} ) } } index.js: 注册路由, 渲染路由器标签 import React from 'react' import {render} from 'react-dom' import {Router, Route, IndexRoute, hashHistory} from 'react-router' import App from './modules/App' import About from './modules/About' import Repos from './modules/Repos' import Home from './modules/Home' render(( ), document.getElementById('app')) 4.6 向路由组件传递请求参数 repo.js: repos 组件下的分路由组件 import React from 'react' export default function ({params}) { let {username, repoName} = params return ( 用户名:{username}, 仓库名:{repoName} ) } repos.js import React from 'react' import NavLink from './NavLink' export default class Repos extends React.Component { constructor(props) { super(props); this.state = { repos: [ {username: 'faceback', repoName: 'react'}, {username: 'faceback', repoName: 'react-router'}, {username: 'Angular', repoName: 'angular'}, {username: 'Angular', repoName: 'angular-cli'} ] }; this.handleSubmit = this.handleSubmit.bind(this) } handleSubmit () { const repos = this.state.repos repos.push({ username: this.refs.username.value, repoName: this.refs.repoName.value }) this.setState({repos}) this.refs.username.value = '' this.refs.repoName.value = '' } render() { return ( Repos { this.state.repos.map((repo, index) => { const to = `/repos/${repo.username}/${repo.repoName}` return ( {repo.repoName} ) }) } / {' '} {' '} 添加 {this.props.children} ); } } index.js: 配置路由 4.7 优化 Link 组件 NavLink.js import React from 'react' import {Link} from 'react-router' export default function NavLink(props) { return } Repos.js {repo.repoName} 总结 参考文档：React-Router 中文文档 参考文档：react-admin完整项目 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-27 19:33:31 "},"src/React/05_redux.html":{"url":"src/React/05_redux.html","title":"Redux","keywords":"","body":"5 Redux 目录 5.1 redux 理解 5.2 redux 相关 API 5.3 redux 核心概念(3 个) 5.4 redux 工作流程(3 个) 5.5 使用 redux 及相关库编码 5.1 redux 理解 什么?: redux 是专门做状态管理的独立第 3 方库, 不是 react 插件 作用?: 对应用中状态进行集中式的管理(写/读) 开发: 与 react-redux, redux-thunk,redux-devtools-extension 等插件配合使用,5 个插件集合相当于 vuex redux 状态管理库，提供 createStore react-redux 连接 react 与 redux 的库，提供 connect redux-thunk 让 actions 支持异步中间件 redux-devtools-extension 让浏览器能调试 redux 5.2 redux 相关 API redux 中包含: createStore(), applyMiddleware(), combineReducers() store 对象: getState(), dispatch(), subscribe() react-redux: , connect()() 5.3 redux 核心概念(3 个) action: 默认是对象(同步 action), {type: 'xxx', data: value}, 需要通过对应的 actionCreator 产生, 它的值也可以是函数(异步 action), 需要引入 redux-thunk 才可以 reducer 根据老的 state 和指定的 action, 返回一个新的 state 不能修改老的 state store redux 最核心的管理对象 内部管理着: state 和 reducer 提供方法: getState(), dispatch(action), subscribe(listener) 5.4 redux 工作流程 5.5 使用 redux 及相关库编码 redux react-redux redux-thunk redux-devtools-extension(这个只在开发时需要) redux 文件夹: action-types.js actions.js reducers.js store.js 组件分 2 类: ui 组件(components): 不使用 redux 相关 API 容器组件(containers): 使用 redux 相关 API 总结 参考文档：Redux 中文文档 参考文档：一个 react + redux 的完整项目 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-27 19:33:31 "},"src/Vue/":{"url":"src/Vue/","title":"Vue ✔","keywords":"","body":"Vue 目录 目录 Vue基本知识 Vue组件化编程 Vue源码分析 Vuex Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-29 15:36:13 "},"src/Vue/01_vue_base.html":{"url":"src/Vue/01_vue_base.html","title":"Vue 基础","keywords":"","body":"1. Vue 基本知识 目录 1.1. Vue 基本认识 1.2. Vue 基本使用 1.3. Vue 对象的选项 1.4 Vue 过渡动画 1.5 Vue 生命周期 1.6 Vue 自定义过滤器 1.7 Vue 内置指令 1.8 Vue 自定义指令 1.9 Vue 基础 DEMO 1.1 Vue 的基本认识 一位华裔前 Google 工程师(尤雨溪)开发的前端 js 库 作用: 动态构建用户界面 特点: 遵循 MVVM 模式 编码简洁, 体积小, 运行效率高, 移动/PC 端开发 它本身只关注 UI, 可以轻松引入 vue 插件和其它第三库开发项目 与其它框架的关联: 借鉴 angular 的模板和数据绑定技术 借鉴 react 的组件化和虚拟 DOM 技术 vue 包含一系列的扩展插件(库): vue-cli: vue 脚手架 vue-resource(axios): ajax 请求 vue-router: 路由 vuex: 状态管理 vue-lazyload: 图片懒加载 vue-scroller: 页面滑动相关 mint-ui: 基于 vue 的组件库(移动端) element-ui: 基于 vue 的组件库(PC 端) 1.2 Vue 基本使用 引入 vue.js 创建 Vue 实例对象(vm), 指定选项(配置)对象 el : 指定 dom 标签容器的选择器 data : 指定初始化状态数据的对象/函数(返回一个对象) 在页面模板中使用双大括号或 vue 指令 1.3 Vue 对象的选项 el 指定 dom 标签容器的选择器 Vue 就会管理对应的标签及其子标签 data 对象或函数类型 指定初始化状态属性数据的对象 vm 也会自动拥有 data 中所有属性 页面中可以直接访问使用 数据代理: 由 vm 对象来代理对 data 中所有属性的操作(读/写) methods 包含多个方法的对象 供页面中的事件指令来绑定回调 回调函数默认有 event 参数, 但也可以指定自己的参数 所有的方法由 vue 对象来调用, 访问 data 中的属性直接使用 this.xxx computed 包含多个方法的对象 对状态属性进行计算返回一个新的数据, 供页面获取显示 一般情况下是相当于是一个只读的属性 利用 set/get 方法来实现属性数据的计算读取, 同时监视属性数据的变化 如何给对象定义 get/set 属性在创建对象时指定: get name () { return xxx } set name (value) { } 对象创建之后指定: Object.defineProperty(obj, age, { get(){}, set(value){} }) watch 包含多个属性监视的对象 分为一般监视和深度监视 xxx: function(value){} xxx : { deep : true, handler : fun(value) } 另一种添加监视方式: vm.$watch('xxx', function(value){}) 1.4 Vue 过渡动画 利用 vue 去操控 css 的 transition/animation 动画 模板: 使用包含带动画的标签 css 样式 .fade-enter-active: 进入过程, 指定进入的 transition .fade-leave-active: 离开过程, 指定离开的 transition .xxx-enter, .xxx-leave-to: 指定隐藏的样式 编码例子 .xxx-enter-active, .xxx-leave-active { transition: opacity .5s } .xxx-enter, .xxx-leave-to { opacity: 0 } hello 1.5 Vue 生命周期 vm/组件对象 生命周期图 主要的生命周期函数(钩子) created() / mounted(): 启动异步任务(启动定时器,发送 ajax 请求, 绑定监听) beforeDestroy(): 做一些收尾的工作 1.6 Vue 自定义过滤器 理解 对需要显示的数据进行格式化后再显示 编码 1.7 Vue 内置指令 v-text/v-html: 指定标签体 v-text : 当作纯文本 v-html : 将 value 作为 html 标签来解析 v-if v-else v-show: 显示/隐藏元素 v-if : 如果 vlaue 为 true, 当前标签会输出在页面中 v-else : 与 v-if 一起使用, 如果 value 为 false, 将当前标签输出到页面中 v-show: 就会在标签中添加 display 样式, 如果 vlaue 为 true, display=block, 否则是 none v-for : 遍历 遍历数组 : v-for=\"(person, index) in persons\" 遍历对象 : v-for=\"value in person\" $key v-on : 绑定事件监听 v-on:事件名, 可以缩写为: @事件名 监视具体的按键: @keyup.keyCode @keyup.enter 停止事件的冒泡和阻止事件默认行为: @click.stop @click.prevent 隐含对象: $event v-bind : 强制绑定解析表达式 html 标签属性是不支持表达式的, 就可以使用 v-bind 可以缩写为::id='name' :class=\"a\" :class=\"{classA : isA, classB : isB}\" :class=\"[classA, classB]\" :style=\"{color : color}\" v-model 双向数据绑定 自动收集用户输入数据 ref : 标识某个标签 ref='xxx' 读取得到标签对象: this.$refs.xxx 1.8 Vue 自定义指令 注册全局指令 Vue.directive('my-directive', function(el, binding){ el.innerHTML = binding.value.toUpperCase() }) 注册局部指令 directives : { 'my-directive':function(el, binding) { el.innerHTML = binding.value.toUpperCase() } } 使用指令 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-17 09:41:11 "},"src/Vue/02_vue_component_programming.html":{"url":"src/Vue/02_vue_component_programming.html","title":"Vue 深入","keywords":"","body":"2. Vue 组件化编程 目录 2.1 Vue 脚手架 2.2 ESlint 2.3 组件化编程 2.4 ajax 2.5 vue-router 2.6 组件化 DEMO 2.1 Vue 脚手架 用来创建 vue 项目的工具包 创建项目:npm install -g vue-cli vue init webpack vue_demo 开发环境运行:cd vue_demo npm install npm run dev 生产环境打包发布 npm run build npm install -g serve serve dist http://localhost:5000 2.2 ESlint 用来做项目编码规范检查的工具 基本原理: 定义了很多规则, 检查项目的代码一旦发现违背了某个规则就输出相应的提示信息 有相应的配置, 可定制检查 2.3 组件化编程 vue 文件包含 3 个部分 export default { props: []/{} data(){}, computed: {} methods: {}, watch: {} filters: {} directives: {} components: {} } 组件化编码的基本流程 拆分界面, 抽取组件 编写静态组件 编写动态组件 初始化数据, 动态显示初始化界面 实现与用户交互功能 组件通信的 5 种方式 props vue 的自定义事件 pubsub 第三方库 slot vuex(后面单独讲) props: 父子组件间通信的基本方式 属性值的 2 大类型: 一般: 父组件-->子组件 函数: 子组件-->父组件 隔层组件间传递: 必须逐层传递(麻烦) 兄弟组件间: 必须借助父组件(麻烦) vue 自定义事件 子组件与父组件的通信方式 用来取代 function props 不适合隔层组件和兄弟组件间的通信 pubsub 第三方库(消息订阅与发布) 适合于任何关系的组件间通信 slot 通信是带数据的标签 注意: 标签是在父组件中解析 vuex 多组件共享状态(数据的管理) 组件间的关系也没有限制 功能比 pubsub 强大, 更适用于 vue 项目 2.4 ajax 相关库: vue-resource: vue 插件, 多用于 vue1.x axios: 第三方库, 多用于 vue2.x vue-resource 使用 // 引入模块 import VueResource from 'vue-resource' // 使用插件 Vue.use(VueResource) // 通过vue/组件对象发送ajax请求 this.$http.get('/someUrl').then((response) => { // success callback console.log(response.data) //返回结果数据 }, (response) => { // error callback console.log(response.statusText) //错误信息 }) axios 使用 // 引入模块 import axios from 'axios' // 发送ajax请求 axios.get(url) .then(response => { console.log(response.data) // 得到返回结果数据 }) .catch(error => { console.log(error.message) }) 2.5 vue-router vue 用来实现 SPA 的插件 使用 vue-router 创建路由器: router/index.jsnew VueRouter({ routes: [ { // 一般路由 path: '/about', component: about }, { // 自动跳转路由 path: '/', redirect: '/about' } ] }) 注册路由器: main.jsimport router from './router' new Vue({ router }) 使用路由组件标签:Go to XXX 编写路由的 3 步 定义路由组件 映射路由 编写路由 2 个标签 嵌套路由children: [ { path: '/home/news', component: news }, { path: 'message', component: message } ] 向路由组件传递数据params: props: 缓存路由组件 路由的编程式导航 this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面) this.$router.back(): 请求(返回)上一个记录路由 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-30 16:22:01 "},"src/Vue/03_vue_source.html":{"url":"src/Vue/03_vue_source.html","title":"Vue 源码","keywords":"","body":"3. Vue 源码分析 目录 3.1 准备 3.2 数据代理(MVVM.js) 3.3 模板解析(compile.js) 3.4 数据劫持-->数据绑定 3.5 源码 DEMO 3.1 准备 [].slice.call(lis): 将伪数组转换为真数组 node.nodeType: 得到节点类型 属性 Object.defineProperty(obj, propertyName, {}): 给对象添加/修改属性(指定描述符) configurable: true/false 是否可以重新 define enumerable: true/false 是否可以枚举(for..in / keys()) value: 指定初始值 writable: true/false value 是否可以修改存取(访问)描述符 get: 函数, 用来得到当前属性值 set: 函数, 用来监视当前属性值的变化 Object.keys(obj): 得到对象自身可枚举的属性名的数组 DocumentFragment: 文档碎片(高效批量更新多个节点) obj.hasOwnProperty(prop): 判断 prop 是否是 obj 自身的属性 3.2 数据代理(MVVM.js) 通过一个对象代理对另一个对象中属性的操作(读/写) 通过 vm 对象来代理 data 对象中所有属性的操作 好处: 更方便的操作 data 中的数据 基本实现流程 通过 Object.defineProperty()给 vm 添加与 data 对象的属性对应的属性描述符 所有添加的属性都包含 getter/setter 在 getter/setter 内部去操作 data 中对应的属性数据 3.3 模板解析(compile.js) 模板解析的关键对象: compile 对象 模板解析的基本流程: 将 el 的所有子节点取出, 添加到一个新建的文档 fragment 对象中 对 fragment 中的所有层次子节点递归进行编译解析处理 对大括号表达式文本节点进行解析 对元素节点的指令属性进行解析 事件指令解析 一般指令解析 将解析后的 fragment 添加到 el 中显示 解析表达式文本节点: textNode.textContent = value 根据正则对象得到匹配出的表达式字符串: 子匹配/RegExp.$1 从 data 中取出表达式对应的属性值 将属性值设置为文本节点的 textContent 事件指令解析: elementNode.addEventListener(事件名, 回调函数.bind(vm)) v-on:click=\"test\" 从指令名中取出事件名 根据指令的值(表达式)从 methods 中得到对应的事件处理函数对象 给当前元素节点绑定指定事件名和回调函数的 dom 事件监听 指令解析完后, 移除此指令属性 一般指令解析: elementNode.xxx = value 得到指令名和指令值(表达式) 从 data 中根据表达式得到对应的值 根据指令名确定需要操作元素节点的什么属性 v-text---textContent 属性 v-html---innerHTML 属性 v-class--className 属性 将得到的表达式的值设置到对应的属性上 移除元素的指令属性 3.4 数据劫持-->数据绑定 数据绑定(model==>View): 一旦更新了 data 中的某个属性数据, 所有界面上直接使用或间接使用了此属性的节点都会更新(更新) 数据劫持 数据劫持是 vue 中用来实现数据绑定的一种技术 基本思想: 通过 defineProperty()来监视 data 中所有属性(任意层次)数据的变化, 一旦变化就去更新界面 四个重要对象 Observer 用来对 data 所有属性数据进行劫持的构造函数 给 data 中所有属性重新定义属性描述(get/set) * 为 data 中的每个属性创建对应的 dep 对象 Dep(Depend) data 中的每个属性(所有层次)都对应一个 dep 对象 创建的时机: 在初始化 define data 中各个属性时创建对应的 dep 对象 在 data 中的某个属性值被设置为新的对象时 对象的结构 { id, // 每个dep都有一个唯一的id subs //包含n个对应watcher的数组(subscribes的简写) } subs 属性说明 当一个 watcher 被创建时, 内部会将当前 watcher 对象添加到对应的 dep 对象的 subs 中 当此 data 属性的值发生改变时, 所有 subs 中的 watcher 都会收到更新的通知, 从而最终更新对应的界面 Compile 用来解析模板页面的对象的构造函数(一个实例) 利用 compile 对象解析模板页面 每解析一个表达式(非事件指令)都会创建一个对应的 watcher 对象, 并建立 watcher 与 dep 的关系 complie 与 watcher 关系: 一对多的关系 Watcher 模板中每个非事件指令或表达式都对应一个 watcher 对象 监视当前表达式数据的变化 创建的时机: 在初始化编译模板时 对象的组成 { vm, //vm对象 exp, //对应指令的表达式 cb, //当表达式所对应的数据发生改变的回调函数 value, //表达式当前的值 depIds //表达式中各级属性所对应的dep对象的集合对象 //属性名为dep的id, 属性值为dep } 总结: dep 与 watcher 的关系: 多对多 一个 data 中的属性对应对应一个 dep, 一个 dep 中可能包含多个 watcher(模板中有几个表达式使用到了属性) 模板中一个非事件表达式对应一个 watcher, 一个 watcher 中可能包含多个 dep(表达式中包含了几个 data 属性) 数据绑定使用到 2 个核心技术 defineProperty() * 消息订阅与发布 双向数据绑定 - 双向数据绑定是建立在单向数据绑定(model==>View)的基础之上的 - 双向数据绑定的实现流程: 在解析 v-model 指令时, 给当前元素添加 input 监听 当 input 的 value 发生改变时, 将最新的值赋值给当前表达式所对应的 data 属性 原理图 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-30 16:32:44 "},"src/Vue/04_vuex.html":{"url":"src/Vue/04_vuex.html","title":"Vuex","keywords":"","body":"4. Vuex 目录 4.1 vuex 是什么 4.2 状态自管理应用 4.3 多组件共享状态的问题 4.4 vuex 的核心概念 4.5 将 vuex 引到项目中 4.6 DEMO 4.1 vuex 是什么 github 站点: https://github.com/vuejs/vuex 在线文档: https://vuex.vuejs.org/zh-cn/ 简单来说: 对应用中组件的状态进行集中式的管理(读/写) 4.2 状态自管理应用 state: 驱动应用的数据源 view: 以声明方式将 state 映射到视图 actions: 响应在 view 上的用户输入导致的状态变化(包含 n 个更新状态的方法) 4.3 多组件共享状态的问题 多个视图依赖于同一状态 来自不同视图的行为需要变更同一状态 以前的解决办法 将数据以及操作数据的行为都定义在父组件 将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递) vuex 就是用来解决这个问题的 4.4 vuex 的核心概念 state vuex 管理的状态对象 它应该是唯一的 const state = { xxx: initValue } mutations 包含多个直接更新 state 的方法(回调函数)的对象 谁来触发: action 中的 commit('mutation 名称') 只能包含同步的代码, 不能写异步代码 const mutations = { yyy (state, data) { // 更新state的某个属性 } } actions 包含多个事件回调函数的对象 通过执行: commit()来触发 mutation 的调用, 间接更新 state 谁来触发: 组件中: $store.dispatch('action 名称') // 'zzz' 可以包含异步代码(定时器, ajax) const actions = { zzz ({commit, state}, data1) { commit('yyy', data2) } } getters 包含多个计算属性(get)的对象 谁来读取: 组件中: $store.getters.xxx const getters = { mmm (state) { return ... } } modules 包含多个 module 一个 module 是一个 store 的配置对象 与一个组件(包含有共享数据)对应 向外暴露 store 对象 export default new Vuex.Store({ state, mutations, actions, getters }) 组件中: import {mapGetters, mapActions} from 'vuex' export default { computed: mapGetters(['mmm']) methods: mapActions(['zzz']) } @click=\"zzz(data)\" 映射 store import store from './store' new Vue({ store }) store 对象 所有用 vuex 管理的组件中都多了一个属性$store, 它就是一个 store 对象 属性: state: 注册的 state 对象 getters: 注册的 getters 对象 方法: dispatch(actionName, data): 分发 action 4.5 将 vuex 引到项目中 下载: npm install vuex --save 使用 vuex store.jsimport Vuex from 'vuex' export default new Vuex.Store({ state, mutations, actions, getters, modules }) main.jsimport store from './store.js' new Vue({ store }) Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-30 16:47:26 "},"src/JavaScript/":{"url":"src/JavaScript/","title":"JavaScript ✔","keywords":"","body":"JavaScript JavaScript 负责页面中的的行为。 它是一门运行在浏览器端的脚本语言。 JS 的编写的位置 可以编写到标签的指定属性中 我是按钮 超链接 可以编写到script标签中 //编写js代码 可以将代码编写到外部的js文件中，然后通过标签将其引入 输出语句 alert(\"要输出的内容\"); 该语句会在浏览器窗口中弹出一个警告框 document.write(\"要输出的内容\"); 该内容将会被写到 body 标签中，并在页面中显示 console.log(\"要输出的内容\"); 该内容会被写到开发者工具的控制台中 基本的语法 注释 单行注释 //注释内容 多行注释 / 注释内容 / JS 严格区分大小写 JS 中每条语句以分号(;)结尾 用熟后可以看情况使用，在以 “(” “[” “/ ” “+” “-” 作为行首必须加分号 JS 中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-16 14:57:40 "},"src/JavaScript/basic/":{"url":"src/JavaScript/basic/","title":"基础知识","keywords":"","body":"基础 目录 字面量和变量 标识符 数据类型 运算符 流程控制语句 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-16 15:06:31 "},"src/JavaScript/basic/01_variable.html":{"url":"src/JavaScript/basic/01_variable.html","title":"字面量和变量","keywords":"","body":" 字面量和变量 字面量 字面量实际上就是一些固定的值，比如 1 2 3 4 true false null NaN \"hello\" 字面量都是不可以改变的。 由于字面量不是很方便使用，所以在JS中很少直接使用字面量 变量 变量可以用来保存字面量，并且可以保存任意的字面量 一般都是通过变量来使用字面量，而不直接使用字面量，而且也可以通过变量来对字面量进行一个描述 声明变量 使用var关键字来声明一个变量 var a; var b; var c; 为变量赋值 a = 1; b = 2; c = 3; 声明和赋值同时进行 var d = 456; var e = 789; Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-16 14:42:54 "},"src/JavaScript/basic/02_identifier.html":{"url":"src/JavaScript/basic/02_identifier.html","title":"标识符","keywords":"","body":" 标识符 在JS中所有的可以自主命名的内容，都可以认为是一个标识符， 是标识符就应该遵守标识符的规范。 比如：变量名、函数名、属性名 规范： 标识符中可以含有字母、数字、_、$ 标识符不能以数字开头 标识符不能是JS中的关键字和保留字 标识符一般采用驼峰命名法 xxxYyyZzz Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-16 14:42:54 "},"src/JavaScript/basic/03_datatype.html":{"url":"src/JavaScript/basic/03_datatype.html","title":"数据类型","keywords":"","body":" JS 中一共分成六种数据类型 String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 Object 对象 其中基本数据类型有 前 5 种 对象为引用数据类型 String 字符串 在JS中字符串需要使用引号引起来 使用双引号或单引号都可以 双引号中只能放单引号（或者反过来，正确嵌套），双引号不能放双引号，单引号不能放单引号 在字符串中使用\\作为转义字符\\' ==> ' \\\" ==> \" \\n ==> 换行 \\t ==> 制表符 \\\\ ==> \\ 使用typeof运算符检查字符串时，会返回\"string\" Number 数值 JS中所有的整数和浮点数都是Number类型 其他进制的数字的表示： 0b 开头表示二进制，但是不是所有的浏览器都支持 0 开头表示八进制 0x 开头表示十六进制 JS中可以表示的数字的最大值 Number.MAX_VALUE =1.7976931348623157e+308 Number.MIN_VALUE =5e-324 大于0的最小值 如果使用Number表示的数字超过了最大值，则会返回一个 Infinity 表示正无穷， -Infinity 表示负无穷 使用typeof检查Infinity也会返回number NaN 是一个特殊的数字，表示Not A Number 使用typeof检查一个NaN也会返回number 如果使用JS进行浮点运算，可能得到一个不精确的结果 （其实所有语言在设计之初都存在某些数据无法精确显示，计算机底层是01表示数据，其他语言有解决方案，JavaScript没有而已） 所以千万不要使用JS进行对精确度要求比较高的运算 Boolean 布尔值 布尔值主要用来进行逻辑判断，布尔值只有两个 true 逻辑的真 false 逻辑的假 使用typeof检查一个布尔值时，会返回\"boolean\" Null 空值 空值专门用来表示为空的对象，Null类型的值只有一个 null 使用typeof检查一个Null类型的值时会返回\"object\" 其他数据类型的typeof值都返回相应的数据类型，null返回object（历史遗留原因） Undefined 未定义 如果声明一个变量但是没有为变量赋值此时变量的值就是undefined 该类型的值只有一个 undefined 使用typeof检查一个Undefined类型的值时，会返回\"undefined\" 引用数据类型 Object 对象 类型转换 类型转换就是指将其他的数据类型，转换为String Number 或 Boolean(主要是转换为这三种类型) 转换为String 方式一（强制类型转换）： 调用被转换数据的toString()方法 var a = 123; a = a.toString(); 注意：这个方法不适用于null和undefined 由于这两个类型的数据中没有方法，所以调用toString()时会报错 方式二（强制类型转换）： 调用String()函数 var a = 123; a = String(a); 原理：对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串， 对于null值，直接转换为字符串\"null\"。对于undefined直接转换为字符串\"undefined\" 方式三（隐式的类型转换）: 为任意的数据类型 +\"\" var a = true; a = a + \"\"; 原理：和String()函数一样 转换为Number 方式一（强制类型转换）： 调用Number()函数 var s = \"123\"; s = Number(s); 转换的情况： 1. 字符串 --> 数字 - 如果字符串是一个合法的数字，则直接转换为对应的数字 \"123\" - 如果字符串是一个非法的数字（空格也一样），则转换为NaN \"123ab\" - 如果是一个空串或纯空格的字符串，则转换为0 “” 2. 布尔值 --> 数字 - true转换为1 - false转换为0 3. 空值 --> 数字 - null转换为0 4. 未定义 --> 数字 - undefined 转换为NaN 方式二（强制类型转换）： 调用parseInt()或parseFloat() 这两个函数专门用来将一个字符串转换为数字的 如果对非String使用parseInt()或parseFloat() 它会先将其转换为String然后在操作 parseInt() 可以将一个字符串中的有效的整数位提取出来，并转换为Number var a = \"123.456px\"; a = parseInt(a); //123 如果需要可以在parseInt()中指定一个第二个参数，来指定进制 parseFloat() 可以将一个字符串中的有效的小数位提取出来，并转换为Number var a = \"123.456px\"; a = parseFloat(a); //123.456 方式三（隐式的类型转换）： 使用一元的+来进行隐式的类型转换 var a = \"123\"; a = +a; 原理：和Number()函数一样 转换为布尔值 方式一（强制类型转换）： 使用Boolean()函数 var s = \"false\"; s = Boolean(s); //true 转换的情况: 字符串 --> 布尔 - 除了空串其余全是true 数值 --> 布尔 - 除了0和NaN其余的全是true null、undefined ---> 布尔 都是false 对象 ---> 布尔 都是true 方式二（隐式类型转换）： 为任意的数据类型做两次非运算，即可将其转换为布尔值 var a = \"hello\"; a = !!a; //true Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-17 09:41:11 "},"src/JavaScript/basic/04_operator.html":{"url":"src/JavaScript/basic/04_operator.html","title":"运算符","keywords":"","body":" 运算符 运算符也称为操作符 通过运算符可以对一个或多个值进行运算或操作 typeof运算符 用来检查一个变量的数据类型 语法：typeof 变量 它会返回一个用于描述类型的字符串作为结果 算数运算符 +对两个值进行加法运算并返回结果 -对两个值进行减法运算并返回结果 *对两个值进行乘法运算并返回结果 /对两个值进行除法运算并返回结果 %对两个值进行取余运算并返回结果 除了字符串加法以外，对非Number类型的值进行算术运算时，都会先转换为Number然后在做运算。 任何值和字符串做加法，都会先转换为字符串，然后再拼串 任何值和NaN做运算都得NaN 一元运算符 一元运算符只需要一个操作数 一元的+ 就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字 例子： var a = true; a = +a; 一元的- 就是负号，可以对一个数字进行符号位取反 例子： var a = 10; a = -a; 自增 自增可以使变量在原值的基础上自增1 自增使用 ++ 自增可以使用 前++（++a）后++(a++) 无论是++a 还是 a++都会立即使原变量自增1 不同的是++a和a++的值是不同的， ++a的值是变量的新值（自增后的值） a++的值是变量的原值（自增前的值） （ 分为三个值，分别为变量的值，表达式a++和++a的值） 自减 自减可以使变量在原值的基础上自减1 自减使用 -- 自减可以使用 前--（--a）后--(a--) 无论是--a 还是 a--都会立即使原变量自减1 不同的是--a和a--的值是不同的， --a的值是变量的新值（自减后的值） a--的值是变量的原值（自减前的值） 练习（对a++ 和 ++a的理解） var n1=10; var n2=20; var n = n1++; //n1 = 11 n1++ = 10 console.log('n='+n); // 10 console.log('n1='+n1); //11 n = ++n1 //n1 = 12 ++n1 =12 console.log('n='+n); //12 console.log('n1='+n1); //12 n = n2--; // n2=19 n2--=20 console.log('n='+n); //20 console.log('n2='+n2); //19 n = --n2; //n2=18 --n2 = 18 console.log('n='+n); //18 console.log('n2='+n2); //18 逻辑运算符 ! 非运算可以对一个布尔值进行取反，true变false false变true 当对非布尔值使用!时，会先将其转换为布尔值然后再取反 我们可以利用!来将其他的数据类型转换为布尔值 && &&可以对符号两侧的值进行与运算 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。 与是一个短路的与，如果第一个值是false，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为false，则返回第一个值 2.如果第一个值为true，则返回第二个值 || ||可以对符号两侧的值进行或运算 只有两端都是false时，才会返回false。只要有一个true，就会返回true。 或是一个短路的或，如果第一个值是true，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为true，则返回第一个值 2.如果第一个值为false，则返回第二个值 //true && true //与运算：如果两个值都为true，则返回后边的 var result = 5 && 6; //6 //与运算：如果两个值中有false，则返回靠前的false //false && true result = 0 && 2; //0 result = 2 && 0; //0 //false &&　false result = NaN && 0; //NaN result = 0 && NaN; //0 //换句话说，&&运算找false，第一个为false返回第一个值，第一个为true返回第二个值 //true || true //如果第一个值为true，则直接返回第一个值 result = 2 || 1; //2 result = 2 || NaN; //2 result = 2 || 0; //2 //如果第一个值为false，则直接返回第二个值 result = NaN || 1; //1 result = NaN || 0; //0 result = \"\" || \"hello\"; //hello result = -1 || \"你好\"; //-1 //换句话说，||运算找true，第一个为true返回第一个值，第一个为false返回第二个值 console.log(\"result = \"+result); 赋值运算符 = 可以将符号右侧的值赋值给左侧变量 += a += 5 相当于 a = a+5 var str = \"hello\"; str += \"world\"; -= a -= 5 相当于 a = a-5 *= a = 5 相当于 a = a5 /= a /= 5 相当于 a = a/5 %= a %= 5 相当于 a = a%5 关系运算符 关系运算符用来比较两个值之间的大小关系的 > = 关系运算符的规则和数学中一致，用来比较两个值之间的关系， 如果关系成立则返回true，关系不成立则返回false。 如果比较的两个值是非数值，会将其转换为Number然后再比较。 如果比较的两个值都是字符串，此时会比较字符串的Unicode编码，而不会转换为Number。 相等运算符 == 相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false 相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的number类型然后再比较， 转换后相等它也会返回true （undefined 衍生自 null，所以这两个值做相等判断时，会返回true） NaN不和任何值相等，包括他本身 可以通过isNaN()函数来判断一个值是否是NaN 如果该值是NaN则返回true，否则返回false != 不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false 不等也会做自动的类型转换。 === 全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换， 如果两个值的类型不同，则直接返回false !== 不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true 三元运算符： ?: 语法：条件表达式?语句1:语句2; 执行流程： 先对条件表达式求值判断， 如果判断结果为true，则执行语句1，并返回执行结果 如果判断结果为false，则执行语句2，并返回执行结果 特殊的值： null和undefined 由于undefined衍生自null，所以null == undefined 会返回true。 但是 null === undefined 会返回false。 NaN NaN不与任何值相等，报告它自身 NaN == NaN //false 判断一个值是否是NaN 使用isNaN()函数 优先级： 和数学中一样，JS中的运算符也是具有优先级的， 比如 先乘除 后加减 先与 后或 具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高， 优先级越高的越优先计算，优先级相同的，从左往右计算。 优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-17 09:41:11 "},"src/JavaScript/basic/05_process_control.html":{"url":"src/JavaScript/basic/05_process_control.html","title":"流程控制语句","keywords":"","body":" 流程控制语句 程序都是自上向下的顺序执行的， 通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。 分类： 条件判断语句 条件分支语句 循环语句 条件判断语句 条件判断语句也称为if语句 语法一： if(条件表达式){ 语句... } 执行流程： if语句执行时，会先对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则不执行 语法二： if(条件表达式){ 语句... }else{ 语句... } 执行流程： if...else语句执行时，会对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则执行else后的语句 语法三： if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else{ 语句... } 执行流程 if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断， 如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。 如果判断结果为false，则继续向下判断，直到找到为true的为止。 如果所有的条件表达式都是false，则执行else后的语句 条件分支语句 switch语句 语法: switch(条件表达式){ case 表达式: 语句... break; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break; } 执行流程： - switch...case...语句在执行时，会依次将case后的表达式的值和switch后 的表达式的值进行全等比较，如果比较结果为false，则继续向下比较。如果比 较结果为true，则从当前case处开始向下执行代码(穿透)。如果所有的case判断 结果都为false，则从default处开始执行代码。 循环语句 通过循环语句可以反复执行某些语句多次 while循环 语法： while(条件表达式){ 语句... } 执行流程： while语句在执行时，会先对条件表达式进行求值判断， 如果判断结果为false，则终止循环 如果判断结果为true，则执行循环体 循环体执行完毕，继续对条件表达式进行求值判断，依此类推 do...while循环 语法: do{ 语句... }while(条件表达式) 执行流程 do...while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断， 如果判断判断结果为false，则终止循环。 如果判断结果为true，则继续执行循环体，依此类推 和while的区别： while：先判断后执行 do...while: 先执行后判断 do...while可以确保循环体至少执行一次。 for循环 语法： for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){ ③语句. } 执行流程： 首先执行①初始化表达式，初始化一个变量， 然后对②条件表达式进行求值判断，如果为false则终止循环 如果判断结果为true，则执行③循环体 循环体执行完毕，执行④更新表达式，对变量进行更新。 更新表达式执行完毕重复② 死循环 while(true){ } for(;;){ } Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-17 09:41:11 "},"src/JavaScript/object/":{"url":"src/JavaScript/object/","title":"面向对象","keywords":"","body":"面向对象 目录 对象 函数 作用域 this 包装类 原型类 数组 字符串相关方法 正则 date math Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-17 09:41:11 "},"src/JavaScript/object/11_object.html":{"url":"src/JavaScript/object/11_object.html","title":"对象","keywords":"","body":" 对象（Object） 对象是JS中的引用数据类型 对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性 使用typeof检查一个对象时，会返回object 对象的分类： 内建对象 由ES标准中定义的对象，在任何的ES的实现中都可以使用 比如：Math String Number Boolean Function Object.... 宿主对象 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象 比如 BOM DOM 自定义对象 由开发人员自己创建的对象 创建对象 方式一： var obj = new Object(); 方式二： var obj = {}; 向对象中添加属性 语法： 对象.属性名 = 属性值; 对象[\"属性名\"] = 属性值; 对象的属性名没有任何要求，不需要遵守标识符的规范， 但是在开发中，尽量按照标识符的要求去写。 属性值也可以任意的数据类型。 读取对象中的属性 语法： 对象.属性名 对象[\"属性名\"] 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined 删除对象中的属性 语法： delete 对象.属性名 delete 对象[\"属性名\"] 使用in检查对象中是否含有指定属性 语法： \"属性名\" in 对象 如果在对象中含有该属性，则返回true 如果没有则返回false 使用对象字面量，在创建对象时直接向对象中添加属性 语法： var obj = { 属性名:属性值, 属性名:属性值, 属性名:属性值, 属性名:属性值 } 基本数据类型和引用数据类型 基本数据类型 String Number Boolean Null Undefined 引用数据类型 Object 基本数据类型的数据，变量是直接保存的它的值（放在栈空间）。 变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。 引用数据类型的数据，变量是保存的对象的引用（内存地址）（栈堆双向）。 如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。 比较两个变量时，对于基本数据类型，比较的就是值， 对于引用数据类型比较的是地址，地址相同才相同 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-17 10:22:46 "},"src/JavaScript/object/01_function.html":{"url":"src/JavaScript/object/01_function.html","title":"函数","keywords":"","body":" 函数（Function） 函数也是一个对象，也具有普通对象的功能 函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码 使用typeof检查一个函数时会返回function 创建函数 函数声明 function 函数名([形参1,形参2...形参N]){ 语句... } 函数表达式 var 函数名 = function([形参1,形参2...形参N]){ 语句... }; 调用函数 语法： 函数对象([实参1,实参2...实参N]); fun() sum() alert() Number() parseInt() 当我们调用函数时，函数中封装的代码会按照编写的顺序执行 形参和实参 形参：形式参数 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开 定义形参就相当于在函数内声明了对应的变量但是并不赋值， 形参会在调用时才赋值。 实参：实际参数 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参, 调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。 如果实参的数量大于形参，多余实参将不会赋值， 如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined 返回值，就是函数执行的结果。 使用return 来设置函数的返回值。 语法：return 值; 该值就会成为函数的返回值，可以通过一个变量来接收返回值 return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。 return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。 如果return后不跟值，或者是不写return则函数默认返回undefined。 break、continue和return break 退出循环 continue 跳过当次循环 return 退出函数 在函数中return后的语句都不会执行 function sum(a , b , c){ var d = a + b + c; return d; alert(\"我不会执行\"); //return undefined; return和不写return都是返回undefined //每个函数都有return值，默认return undefined } 立即执行函数 函数定义完，立即被调用，这种函数叫做立即执行函数 立即执行函数往往只会执行一次 (function(){ alert(\"我是一个匿名函数~~~\"); })() 匿名函数自调用，闭包 参数，函数的实参也可以是任意的数据类型。 方法（method） 可以将一个函数设置为一个对象的属性，当一个对象的属性是一个函数时， 我们称这个函数是该对象的方法。 对象.方法名(); 函数名(); call() , apply() 这两个方法都是函数对象的方法需要通过函数对象来调用 通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this 不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递 三种方法调用函数 fun(); fun.apply(); fun.call(); 不同之处，可以传一个对象进去，指定this fun.call(obj,2,3); fun.apply(obj,[2,3]); arguments arguments和this类似，都是函数中的隐含的参数 arguments是一个类数组元素，它用来封装函数执行过程中的实参 所以即使不定义形参，也可以通过arguments来使用实参 arguments中有一个属性callee表示当前执行的函数对象 构造函数 构造函数是专门用来创建对象的函数 一个构造函数我们也可以称为一个类 通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例（通过instanceof检测是否是该函数的实例） 通过同一个构造函数创建的对象，我们称为一类对象 构造函数就是一个普通的函数，只是他的调用方式不同，构造函数习惯上首字母大写 如果直接调用，它就是一个普通函数 如果使用new来调用，则它就是一个构造函数 例子： function Person(){ } //构造函数通常首字母大写，提醒我们用new调用函数，当成构造函数创建对象 function Person(name , age , gender){ this.name = name; this.age = age; this.gender = gender; this.sayName = function(){ alert(this.name); }; } var per = new Person(\"孙悟空\",18,\"男\"); 构造函数的执行流程： 创建一个新的对象 将新的对象作为函数的上下文对象（this） 执行函数中的代码 将新建的对象返回 instanceof 用来检查一个对象是否是一个类的实例 语法：对象 instanceof 构造函数 如果该对象时构造函数的实例，则返回true，否则返回false Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true //console.log(per instanceof Person); true //console.log(per instanceof Object); true //console.log(dog instanceof Person); false 枚举对象中的属性:for...in 语法： for(var 属性名 in 对象){ } for...in语句的循环体会执行多次，对象中有几个属性就会执行几次， 每次将一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-17 13:59:34 "},"src/JavaScript/object/02_scope.html":{"url":"src/JavaScript/object/02_scope.html","title":"作用域","keywords":"","body":" 作用域 作用域简单来说就是一个变量的作用范围。 在JS中作用域分成两种： 全局作用域 直接在script标签中编写的代码都运行在全局作用域中 全局作用域在打开页面时创建，在页面关闭时销毁。 全局作用域中有一个全局对象window，window对象由浏览器提供， 可以在页面中直接使用，它代表的是整个的浏览器的窗口。 在全局作用域中创建的变量都会作为window对象的属性保存 在全局作用域中创建的函数都会作为window对象的方法保存 在全局作用域中创建的变量和函数可以在页面的任意位置访问。 在函数作用域中也可以访问到全局作用域的变量。 尽量不要在全局中创建变量 函数作用域 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。 函数作用域在函数执行时创建，在函数执行结束时销毁。 在函数作用域中创建的变量，不能在全局中访问。 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找， 如果找到了则直接使用，如果没有找到则到上一级作用域中寻找， 如果找到了则使用，找不到则继续向上找 变量的声明提前 在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。 所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。 在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明， 如果没有使用var关键字声明变量，则变量会变成全局变量 函数的声明提前 在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建， 也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性 在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-17 14:25:09 "},"src/JavaScript/object/03_this.html":{"url":"src/JavaScript/object/03_this.html","title":"this","keywords":"","body":" this（上下文对象） 我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。 使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。 this的不同的情况： 以函数的形式调用时，this是window 以方法的形式调用时，this是调用方法的对象 以构造函数的形式调用时，this是新建的那个对象 使用call和apply调用时，this是指定的那个对象 箭头函数中的this，官方定义指向它所处的环境的对象， 自行理解：箭头函数会去找外层函数的this，如果仍是箭头函数， 继续往上找，如果没有，则是window Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-17 14:29:02 "},"src/JavaScript/object/04_class.html":{"url":"src/JavaScript/object/04_class.html","title":"包装类","keywords":"","body":" 在JS中为我们提供了三个包装类：Number() String() Boolean() 通过这三个包装类可以创建基本数据类型的对象 例子： var num = new Number(2); var str = new String(\"hello\"); var bool = new Boolean(true); 但是在实际应用中千万不要这么干。 当我们去操作一个基本数据类型的属性和方法时， 解析器会临时将其转换为对应的包装类，然后再去操作属性和方法， 操作完成以后再将这个临时对象进行销毁。 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-17 14:32:59 "},"src/JavaScript/object/05_prototype.html":{"url":"src/JavaScript/object/05_prototype.html","title":"原型","keywords":"","body":" 原型（prototype） 创建一个函数以后，解析器都会默认在函数中添加一个数prototype， prototype属性指向的是一个对象，这个对象我们称为原型对象。 当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。 这个隐含的属性可以通过对象.proto来访问。 mc.a会返回 自身的，mc2.a会返回原型中的a，（先从自身中找属性，然后找原型中的） 原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。 我们可以将对象中共有的属性和方法统一添加到原型对象中， 这样我们只需要添加一次，就可以使所有的对象都可以使用。 当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找， 如果在自身中找到了，则直接使用。 如果没有找到，则去原型对象中寻找，如果找到了则使用， 如果没有找到，则去原型的原型中寻找，依此类推。直到找到Object的原型为止，Object的原型的原型为null， 如果依然没有找到则返a回undefined hasOwnProperty() 这个方法可以用来检查对象自身中是否含有某个属性 语法： 对象.hasOwnProperty(\"属性名\") 与in对应 属性名 in 对象 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true 为什么要有原型这个概念，并且浏览器默认给每个函数都添加prototype这个属性？ 起因：创建一个Person构造函数 在Person构造函数中，为每一个对象都添加了一个sayName方法， 目前我们的方法是在构造函数内部创建的， 也就是构造函数每执行一次就会创建一个新的sayName方法 也是所有实例的sayName都是唯一的。 这样就导致了构造函数执行一次就会创建一个新的方法， 执行10000次就会创建10000个新的方法，而10000个方法都是一摸一样的 这是完全没有必要，完全可以使所有的对象共享同一个方法 function Person(name , age , gender){ this.name = name; this.age = age; this.gender = gender; //向对象中添加一个方法 this.sayName = function(){ alert(\"Hello大家好，我是:\"+this.name); } } 经过： function Person(name , age , gender){ this.name = name; this.age = age; this.gender = gender; //向对象中添加一个方法 this.sayName = fun; } //将公共的部分提取出来 function fun(){ alert(\"Hello大家好，我是:\"+this.name); }; 结果： //将sayName方法在全局作用域中定义 /* * 将函数定义在全局作用域，污染了全局作用域的命名空间 * 而且定义在全局作用域中也很不安全 */ //向原型中添加sayName方法，不会污染全局空间，而且由Person构造函数实例化 的对象，现在自己内部属性中找，找不到去原型中找 Person.prototype.sayName = function(){ alert(\"Hello大家好，我是:\"+this.name); }; //创建一个Person的实例 var per = new Person(\"孙悟空\",18,\"男\"); var per2 = new Person(\"猪八戒\",28,\"男\"); per.sayName(); per2.sayName(); //console.log(per.sayName == per2.sayName); Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-17 15:06:51 "},"src/JavaScript/object/06_array.html":{"url":"src/JavaScript/object/06_array.html","title":"数组","keywords":"","body":" 数组（Array） 数组也是一个对象，是一个用来存储数据的对象 和Object类似，但是它的存储效率比普通对象要高 数组中保存的内容我们称为元素 数组使用索引（index）来操作元素 索引指由0开始的整数 数组的操作： 创建数组 var arr = new Array(); var arr = []; 向数组中添加元素 语法； 数组对象[索引] = 值; arr[0] = 123; arr[1] = \"hello\"; 创建数组时直接添加元素 语法： var arr = [元素1,元素2....元素N]; 获取和修改数组的长度 使用length属性来操作数组的长度 获取长度：数组.length length获取到的是数组的最大索引+1 对于连续的数组，length获取到的就是数组中元素的个数 修改数组的长度: 数组.length = 新长度 如果修改后的length大于原长度，则多出的部分会空出来 如果修改后的length小于原长度，则原数组中多出的元素会被删除 向数组的最后添加元素 数组[数组.length] = 值; 数组的方法 push() 用来向数组的末尾添加一个或多个元素，并返回数组新的长度 语法：数组.push(元素1,元素2,元素N) pop() 用来删除数组的最后一个元素，并返回被删除的元素 unshift() 向数组的前边添加一个或多个元素，并返回数组的新的长度 shift() 删除数组的前边的一个元素，并返回被删除的元素 slice() 可以从一个数组中截取指定的元素 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回 参数： 截取开始位置的索引（包括开始位置） 截取结束位置的索引（不包括结束位置） 第二个参数可以省略不写，如果不写则一直截取到最后 参数可以传递一个负值，如果是负值，则从后往前数 splice() 可以用来删除数组中指定元素，并使用新的元素替换 该方法会将删除的元素封装到新数组中返回 参数： 删除开始位置的索引 删除的个数 三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边 reverse() 可以用来反转一个数组，它会对原数组产生影响 concat() 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回 join() 可以将一个数组转换为一个字符串 参数： 需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素 如果不指定连接符则默认使用, 跟字符串的spilt()相反 arr = [\"孙悟空\",\"猪八戒\",\"沙和尚\",\"唐僧\"]; result = arr.join(\"@-@\"); //孙悟空@-@猪八戒@-@沙和尚@-@唐僧 sort() 可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序(所以对数字进排序时，可能会得到错误的结果 ) 调用以后，会直接修改原数组。 可以自己指定排序的规则，需要一个回调函数作为参数： arr.sort(function(a,b){ //升序排列 //return a-b; //降序排列 return b-a; } 遍历数组 遍历数组就是将数组中元素都获取到 一般情况我们都是使用for循环来遍历数组： for(var i=0 ; i 使用forEach()方法来遍历数组（不兼容IE8） 数组.forEach(function(value , index , obj){ }); forEach()方法需要一个回调函数作为参数， 数组中有几个元素，回调函数就会被调用几次， 每次调用时，都会将遍历到的信息以实参的形式传递进来， 我们可以定义形参来获取这些信息。 value:正在遍历的元素 index:正在遍历元素的索引 obj:被遍历对象 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-17 17:35:48 "},"src/JavaScript/object/07_string_func.html":{"url":"src/JavaScript/object/07_string_func.html","title":"字符串的相关方法","keywords":"","body":" 为什么基本数据类型的string能运用，String对象的属性，方法？ 因为浏览器的包装类机制，它会临时将基本数据类型包装为字符串对象，然后执行方法，结束后销毁对象 在底层字符串是以字符数组的形式保存的 [\"H\",\"e\",\"l\"]所以有数组的一些方法，属性 length 获取字符串的长度 charAt() 根据索引获取指定的字符 str.charAt(0)或者str[0] charCodeAt() 根据索引获取指定的字符编码 String.fromCharCode() 根据字符编码获取字符 indexOf() lastIndexOf() 从一个字符串中检索指定内容 需要一个字符串作为参数，这个字符串就是要检索的内容， 如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。 可以指定一个第二个参数，来表示开始查找的位置 indexOf()是从前向后找 lastIndexOf()是从后向前找 slice() 可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量 参数： 第一个：截取开始的位置（包括开始） 第二个：截取结束的位置（不包括结束） 可以省略第二个参数，如果省略则一直截取到最后 可以传负数，如果是负数则从后往前数 substr() 和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量 substring() 和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0， substring()中如果第二个参数小于第一个，自动调整位置 toLowerCase() 将字符串转换为小写并返回 toUpperCase() 将字符串转换为大写并返回 split() 可以根据指定内容将一个字符串拆分为一个数组 参数： 需要一个字符串作为参数，将会根据字符串去拆分数组 可以接收一个正则表达式，此时会根据正则表达式去拆分数组 match() 可以将字符串中和正则表达式匹配的内容提取出来 参数： 正则表达式，可以根据该正则表达式将字符串中符合要求的内容提取出来 并且封装到一个数组中返回 replace() 可以将字符串中指定内容替换为新的内容 参数： 第一个：被替换的内容，可以是一个正则表达式 第二个：替换的新内容 search() 可以根据正则表达式去字符串中查找指定的内容 参数： 正则表达式，将会根据该表达式查询内容， 并且将第一个匹配到的内容的索引返回，如果没有匹配到任何内容，则返回-1。 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-18 15:51:23 "},"src/JavaScript/object/08_regexp.html":{"url":"src/JavaScript/object/08_regexp.html","title":"正则","keywords":"","body":" 正则表达式 正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则， 也可以将一个字符串中符合规则的内容提取出来。 创建正则表达式 var reg = new RegExp(\"正则\",\"匹配模式\"); var reg = /正则表达式/匹配模式 语法： 匹配模式： i:忽略大小写 g:全局匹配模式 设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求 正则语法 | 或 [] 或 [^ ] 除了 [a-z] 小写字母 [A-Z] 大写字母 [A-z] 任意字母 [0-9] 任意数字 方法：test() 可以用来检查一个字符串是否符合正则表达式 如果符合返回true，否则返回false var reg = new RegExp(\"ab\",\"i\"); var str = \"a\"; var result = reg.test(str); console.log(result); //true 量词 {n} 正好n次 {m,n} m-n次 {m,} 至少m次 + 至少1次 {1,} ? 0次或1次 {0,1} * 0次或多次 {0,} var reg = /a{3}/; //ababab reg = /(ab){3}/; reg = /b{3}/; reg = /ab{1,3}c/; reg = /ab{3,}c/; reg = /ab+c/; reg = /ab*c/; reg = /ab?c/; 转义字符 \\ 在正则表达式中使用\\作为转义字符 \\. 表示. 只有一个 . 代表任意字符 \\\\ 表示\\ . 表示任意字符 \\w - 相当于[A-z0-9_] 任意字母数字下划线 \\W - 相当于[^A-z0-9_] 除了任意字母数字下划线 \\d - 任意数字 \\D - 除了数字 \\s - 空格 \\S - 除了空格 \\b - 单词边界 \\B - 除了单词边界 ^ 表示开始 $ 表示结束 reg = /^a$/; 只能是a 例子： var str = \"1a2b3c4d5e6f7\"; /* * split() * - 可以将一个字符串拆分为一个数组 * - 方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串 * - 这个方法即使不指定全局匹配，也会全都插分 */ /* * 根据任意字母来将字符串拆分 */ var result = str.split(/[A-z]/); //console.log(result); /* * search() * - 可以搜索字符串中是否含有指定内容 * - 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1 * - 它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串 * - serach()只会查找第一个，即使设置全局匹配也没用 * - indexof作用相似，但是不能传正则表达式 */ str = \"hello abc hello aec afc\"; /* * 搜索字符串中是否含有abc 或 aec 或 afc */ result = str.search(/abc/); //console.log(result); /* * match() * - 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来 * - 默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索 * 我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容 * 可以为一个正则表达式设置多个匹配模式，且顺序无所谓 * - match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果 * * */ str = \"1a2a3a4a5e6f7A8B9C\"; result = str.match(/[a-z]/ig); //console.log(result[2]); /* * replace() * - 可以将字符串中指定内容替换为新的内容 * - 参数： * 1.被替换的内容，可以接受一个正则表达式作为参数 * 2.新的内容 * - 默认只会替换第一个 */ //result = str.replace(/[a-z]/gi , \"@_@\"); result = str.replace(/[a-z]/gi , \"\"); //console.log(result); Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-18 15:51:23 "},"src/JavaScript/object/09_date.html":{"url":"src/JavaScript/object/09_date.html","title":"Date","keywords":"","body":" Date 日期的对象，在JS中通过Date对象来表示一个时间 创建对象 创建一个当前的时间对象 var d = new Date(); 创建一个指定的时间对象 var d = new Date(\"月/日/年 时:分:秒\"); 方法： getDate() 当前日期对象是几日（1-31） getDay() 返回当前日期对象时周几（0-6） 0 周日 1 周一 。。。 getMonth() 返回当前日期对象的月份（0-11） 0 一月 1 二月 。。。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回当前日期对象的时间戳 时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数 计算机底层保存时间都是以时间戳的形式保存的。 Date.now() 可以获取当前代码执行时的时间戳 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-18 15:51:23 "},"src/JavaScript/object/10_math.html":{"url":"src/JavaScript/object/10_math.html","title":"Math","keywords":"","body":" Math Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法 我们可以直接使用它来进行数学运算相关的操作 方法： Math.PI 常量，圆周率 Math.abs() 绝对值运算 Math.ceil() 向上取整 Math.floor() 向下取整 Math.round() 四舍五入取整 Math.random() 生成一个0-1之间的随机数 Math.pow(x,y) 求x的y次幂 Math.sqrt() 对一个数进行开方 Math.max() 求多个数中最大值 Math.min() 求多个数中的最小值 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-18 15:51:23 "},"src/JavaScript/DOM/":{"url":"src/JavaScript/DOM/","title":"DOM","keywords":"","body":" DOM Document Object Model 文档对象模型，通过DOM可以来任意来修改网页中各个内容 文档 文档指的是网页，一个网页就是一个文档 对象 对象指将网页中的每一个节点都转换为对象 转换完对象以后，就可以以一种纯面向对象的形式来操作网页了 模型 模型用来表示节点和节点之间的关系，方便操作页面 节点（Node） 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点 虽然都是节点，但是节点的类型却是不同的 常用的节点 文档节点 （Document），代表整个网页 元素节点（Element），代表网页中的标签 属性节点（Attribute），代表标签中的属性 文本节点（Text），代表网页中的文本内容 文档的加载 浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。 如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载， 此时将会无法正常获取到DOM对象，导致DOM操作失败。 解决方式一： 可以将js代码编写到body的下边 按钮 var btn = document.getElementById(\"btn\"); btn.onclick = function(){ }; 解决方式二： 将js代码编写到window.onload = function(){}中 window.onload 对应的回调函数会在整个页面加载完毕以后才执行， 所以可以确保代码执行时，DOM对象已经加载完毕了 window.onload = function(){ var btn = document.getElementById(\"btn\"); btn.onclick = function(){ }; }; Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-18 15:51:23 "},"src/JavaScript/DOM/01_search.html":{"url":"src/JavaScript/DOM/01_search.html","title":"DOM查询","keywords":"","body":" DOM操作 DOM查询 在网页中浏览器已经为我们提供了document对象， 它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。 document查询方法： 根据元素的id属性查询一个元素节点对象： document.getElementById(\"id属性值\"); 根据元素的name属性值查询一组元素节点对象: document.getElementsByName(\"name属性值\"); 根据标签名来查询一组元素节点对象： document.getElementsByTagName(\"标签名\"); 通过具体的元素节点来查询 元素.getElementsByTagName() 通过标签名查询当前元素的指定后代元素 元素.childNodes 获取当前元素的所有子节点 会获取到空白的文本子节点 元素.children 获取当前元素的所有子元素 元素.firstChild 获取当前元素的第一个子节点 元素.lastChild 获取当前元素的最后一个子节点 元素.parentNode 获取当前元素的父元素 元素.previousSibling 获取当前元素的前一个兄弟节点 元素.nextSibling 获取当前元素的后一个兄弟节点 innerHTML和innerText 这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性 两个属性作用类似，都可以获取到标签内部的内容， 不同是innerHTML会获取到html标签，而innerText会自动去除标签 如果使用这两个属性来设置标签内部的内容时，没有任何区别的 读取标签内部的文本内容 h1中的文本内容 元素.firstChild.nodeValue document对象的其他的属性和方法 document.all 获取页面中的所有元素，相当于document.getElementsByTagName(\"*\"); document.documentElement 获取页面中html根元素 document.body 获取页面中的body元素 document.getElementsByClassName() 根据元素的class属性值查询一组元素节点对象 这个方法不支持IE8及以下的浏览器 document.querySelector() 根据CSS选择器去页面中查询一个元素 如果匹配到的元素有多个，则它会返回查询到的第一个元素 document.querySelectorAll() 根据CSS选择器去页面中查询一组元素 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-18 15:51:23 "},"src/JavaScript/DOM/02_edit.html":{"url":"src/JavaScript/DOM/02_edit.html","title":"DOM修改","keywords":"","body":" 元素的属性： 读取元素的属性： 语法：元素.属性名 例子： ele.name ele.id ele.value ele.className 修改元素的属性： 语法：元素.属性名 = 属性值 innerHTML 使用该属性可以获取或设置元素内部的HTML代码 document.createElement() 可以根据标签名创建一个元素节点对象 document.createTextNode() 可以根据文本内容创建一个文本节点对象 父节点.appendChild(子节点) 向父节点中添加指定的子节点 父节点.insertBefore(新节点,旧节点) 将一个新的节点插入到旧节点的前边 父节点.replaceChild(新节点,旧节点) 使用一个新的节点去替换旧节点 父节点.removeChild(子节点) 删除指定的子节点 推荐方式：子节点.parentNode.removeChild(子节点) DOM对CSS的操作 读取和修改内联样式 使用style属性来操作元素的内联样式 读取内联样式： 语法：元素.style.样式名 例子： 元素.style.width 元素.style.height 注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法 将-去掉，然后-后的字母改大写 比如：background-color --> backgroundColor border-width ---> borderWidth 修改内联样式： 语法：元素.style.样式名 = 样式值 通过style修改的样式都是内联样式，由于内联样式的优先级比较高， 所以我们通过JS来修改的样式，往往会立即生效， 但是如果样式中设置了!important，则内联样式将不会生效。 读取元素的当前样式 正常浏览器 使用getComputedStyle() 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式 参数： 要获取样式的元素 可以传递一个伪元素，一般传null 例子： 获取元素的宽度 getComputedStyle(box , null)[\"width\"]; 通过该方法读取到样式都是只读的不能修改 IE8 使用currentStyle 语法： 元素.currentStyle.样式名 例子： box.currentStyle[\"width\"] 通过这个属性读取到的样式是只读的不能修改 其他的样式相关的属性 注意：以下样式都是只读的 clientHeight 元素的可见高度，指元素的内容区和内边距的高度 clientWidth 元素的可见宽度，指元素的内容区和内边距的宽度 offsetHeight 整个元素的高度，包括内容区、内边距、边框 offfsetWidth 整个元素的宽度，包括内容区、内边距、边框 offsetParent 当前元素的定位父元素 离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body offsetLeft offsetTop 当前元素和定位父元素之间的偏移量 offsetLeft水平偏移量 offsetTop垂直偏移量 scrollHeight scrollWidth 获取元素滚动区域的高度和宽度 scrollTop scrollLeft 获取元素垂直和水平滚动条滚动的距离 判断滚动条是否滚动到底 垂直滚动条 scrollHeight - scrollTop = clientHeight 水平滚动 scrollWidth - scrollLeft = clientWidth Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-18 15:51:23 "},"src/JavaScript/DOM/03_event.html":{"url":"src/JavaScript/DOM/03_event.html","title":"DOM事件","keywords":"","body":" 事件（Event） 事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。 我们可以为事件来绑定回调函数来响应事件。 绑定事件的方式： 可以在标签的事件属性中设置相应的JS代码 例子： 按钮 可以通过为对象的指定事件属性设置回调函数的形式来处理事件 例子： 按钮 var btn = document.getElementById(\"btn\"); btn.onclick = function(){ }; 事件对象 当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中， 这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。 可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存 例子： 元素.事件 = function(event){ event = event || window.event; //兼容IE8以下的写法 }; 元素.事件 = function(e){ e = e || event; }; 事件的冒泡（Bubble） 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。 我是box1 我是span 说白了就是点span的时候，触发span点击事件，也会触发div的点击事件，因为点span的同时，也点到了div的区域 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消 可以将事件对象的cancelBubble设置为true，即可取消冒泡 例子： 元素.事件 = function(event){ event = event || window.event; event.cancelBubble = true; }; chrome认为浏览器的滚动条是body的，可以通过body.scrollTop来获取 火狐等浏览器认为浏览器的滚动条是html的，需要解决兼容问题 var st = document.body.scrollTop || document.documentElement.scrollTop; var sl = document.body.scrollLeft || document.documentElement.scrollLeft; Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-18 16:24:40 "},"src/JavaScript/BOM/":{"url":"src/JavaScript/BOM/","title":"BOM","keywords":"","body":" BOM 浏览器对象模型 BOM可以使我们通过JS来操作浏览器 在BOM中为我们提供了一组对象，用来完成对浏览器的操作 BOM对象 Window 代表的是整个浏览器的窗口，同时window也是网页中的全局对象 Navigator 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 Location 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面 History 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页 而且该操作只在当次访问时有效 Screen 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 这些BOM对象在浏览器中都是作为window对象的属性保存的， 可以通过window对象来使用，也可以直接使用 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-18 16:27:18 "},"src/JavaScript/high/":{"url":"src/JavaScript/high/","title":"高级总结","keywords":"","body":"函数非常重要，浏览器也悄悄给它做了很多事情 传了 arguments arguments用来收集传入的实参，es6中被三点运算符代替 this 函数对象 （event） 给每个函数添加了prototype属性，其中构造函数对其应用比较多 每个函数都有返回值，有return立马结束函数，返回值，如果没有默认返回undefined Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-18 16:49:29 "},"src/JavaScript/high/01_base.html":{"url":"src/JavaScript/high/01_base.html","title":"基础总结深入","keywords":"","body":"数据类型的分类和判断 基本(值)类型 判断类型 Number ----- 任意数值 -------- typeof typeof a==='number' String ----- 任意字符串 ------ typeof typeof a==='string' Boolean ---- true/false ----- typeof typeof a==='boolean' undefined --- undefined -----typeof/ === typeof a==='undefined', a===undefined null -------- null ---------- === a===null 对象(引用)类型 Object ----- typeof/instanceof Array ------ instanceof Function ---- typeof 判断数据数据类型或者相等都最好用 === ,因为它先判断数据类型，在判断值，不会类型转换 typeof 返回值是，当前类型的字符串形式，因此等式右边的类型要加引号来判断 var a; console.log(typeof a === ‘undefined’) //true console.log(a, typeof a, typeof a==='undefined',a===undefined ) // undefined 'undefined' true true undefined 与 null 的区别? undefined 代表定义未赋值 nulll 定义并赋值了, 只是值为 null 什么时候给变量赋值为 null 呢? 初始赋值, 表明将要赋值为对象 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值 数据,变量, 内存的理解 什么是数据? 在内存中可读的, 可传递的保存了特定信息的'东东' 一切皆数据, 函数也是数据 在内存中的所有操作的目标: 数据 什么是变量? 在程序运行过程中它的值是允许改变的量 一个变量对应一块小内存, 它的值保存在此内存中 什么是内存? 内存条通电后产生的存储空间(临时的) 一块内存包含 2 个方面的数据 内部存储的数据 地址值数据 内存空间的分类 栈空间: 全局变量和局部变量 堆空间: 对象 内存,数据, 变量三者之间的关系 内存是容器, 用来存储不同数据 变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据 问题: var a = xxx, a 内存中到底保存的是什么? xxx 是基本数据, 保存的就是这个数据 xxx 是对象, 保存的是对象的地址值 xxx 是一个变量, 保存的 xxx 的内存内容(可能是基本数据, 也可能是地址值) 关于引用变量赋值问题 2 个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 2 个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 在 js 调用函数时传递变量参数时, 是值传递还是引用传递 理解 1: 都是值(基本/地址值)传递 理解 2: 可能是值传递, 也可能是引用传递(地址值) JS 引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数调用时立马产生，执行完时立马自动释放 对象: 成为垃圾对象==>垃圾回收器回收 在某个时刻回收 对象的理解和使用 什么是对象? 多个数据的封装体 用来保存多个数据的容器 一个对象代表现实中的一个事物 为什么要用对象? 统一管理多个数据 属性组成: 属性名 : 字符串(标识) 属性值 : 任意类型 属性的分类: 一般 : 属性值不是 function 描述对象的状态 方法 : 属性值为 function 的属性 描述对象的行为 特别的对象 数组: 属性名是 0,1,2,3 之类的索引 函数: 可以执行的 如何操作内部属性(方法) .属性名 - ['属性名']: 属性名有特殊字符/属性名是一个变量 函数的理解和使用 什么是函数? 用来实现特定功能的, n 条语句的封装体 只有函数类型的数据是可以执行的, 其它的都不可以 为什么要用函数? 提高复用性 便于阅读交流 如何定义函数? 函数声明 表达式 如何调用(执行)函数? test(): 直接调用 obj.test(): 通过对象调用 new test(): new 调用 test.call/apply(obj): 临时让 test 成为 obj 的方法进行调用,修改方法中的 this 函数也是对象 instanceof Object===true 函数有属性: prototype 函数有方法: call()/apply() 可以添加新的属性/方法 函数的 3 种不同角色 一般函数 : 直接调用 构造函数 : 通过 new 调用 对象 : 通过.调用内部的属性/方法 函数中的 this 显式指定谁: obj.xxx() 通过 call/apply 指定谁调用: xxx.call(obj) 不指定谁调用: xxx() : window 回调函数: 看背后是通过谁来调用的: window/其它 例子： Person(\"red\"); //this 是谁? window var p = new Person(\"yello\"); //this是谁? p p.getColor(); //this是谁? p var obj = {}; p.setColor.call(obj, \"black\"); //this是谁? obj 回调函数的理解 什么函数才是回调函数? 你定义的 你没有调用 但它最终执行了(在一定条件下或某个时刻) 常用的回调函数 dom 事件回调函数 ==>发生事件的 dom 元素 与用户交互 onclick onmousemove 定时器回调函数 ===>window ajax 请求回调函数(后面讲解) 与后台交互 生命周期回调函数(后面讲解) 匿名函数自调用: `(function(w, obj){ //实现代码 })(window, obj)` 专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式 作用 隐藏实现 单独开辟局部作用域，不会污染外部(全局)命名空间，达到立即执行效果 用它来编码 js 模块，模块化开发 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-18 17:29:01 "},"src/JavaScript/high/02_function.html":{"url":"src/JavaScript/high/02_function.html","title":"函数高级","keywords":"","body":"原型与原型链 所有函数都有一个特别的属性: 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象) 原型对象中有一个属性constructor, 它指向函数对象 给原型对象添加属性(一般都是方法) 作用: 函数的所有实例对象自动拥有原型中的属性(方法) 所有实例对象都有一个特别的属性: __proto__ : 隐式原型属性 //定义构造函数 function Fn() { // 内部语句: this.prototype = {} } // 1. 每个函数function都有一个prototype，即显式原型属性, 默认指向一个空的Object对象 console.log(Fn.prototype) // 2. 每个实例对象都有一个__proto__，可称为隐式原型 //创建实例对象 var fn = new Fn() // 内部语句: this.__proto__ = Fn.prototype console.log(fn.__proto__) // 3. 对象的隐式原型的值为其对应构造函数的显式原型的值 console.log(Fn.prototype===fn.__proto__) // true //给原型添加方法 Fn.prototype.test = function () { console.log('test()') } //通过实例调用原型的方法 fn.test() 显式原型与隐式原型的关系 函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象 实例对象的proto: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值 原型对象即为当前实例对象的父对象 原型链 所有的实例对象都有proto属性, 它指向的就是原型对象 这样通过proto属性就形成了一个链的结构---->原型链 当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作 显式原型与隐式原型 原型链分析 原型链继承 instanceof是如何判断的? 表达式: A instanceof B 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false Function是通过new自己产生的实例 /- 案例1 -/ function Foo() { } var f1 = new Foo() console.log(f1 instanceof Foo) // true console.log(f1 instanceof Object) // true /- 案例2 -/ console.log(Object instanceof Function) // true console.log(Object instanceof Object) // true console.log(Function instanceof Function) // true console.log(Function instanceof Object) // true function Foo() {} console.log(Object instanceof Foo) // false 测试题1 function A () { } A.prototype.n = 1 var b = new A() A.prototype = { n: 2, m: 3 } var c = new A() console.log(b.n, b.m, c.n, c.m) //1 undefined 2 3 /- 测试题2 -/ function F (){} Object.prototype.a = function(){ console.log('a()') } Function.prototype.b = function(){ console.log('b()') } var f = new F() f.a() //a() // f.b() //报错 F.a() //a() F.b() //b() // console.log(f) // console.log(Object.prototype) // console.log(Function.prototype) 执行上下文与执行上下文栈 理解 执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性 执行上下文栈: 用来管理产生的多个执行上下文，（栈的特点后进先出） 预处理机制 js引擎在执行JavaScript脚本时，有两个阶段，预处理阶段 和 执行阶段 所以才会有变量提升和函数提升 代码分类(位置) 全局代码 函数代码 全局执行上下文 （预处理阶段） 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理 var定义的全局变量==>undefined, 添加为window的属性 function声明的全局函数==>赋值(fun), 添加为window的方法 this==>赋值(window) 开始执行全局代码 函数执行上下文 （预处理阶段） 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象 对局部数据进行预处理 形参变量==>赋值(实参)==>添加为执行上下文的属性 arguments==>赋值(实参列表，伪数组), 添加为执行上下文的属性 var定义的局部变量==>undefined, 添加为执行上下文的属性 function声明的函数 ==>赋值(fun), 添加为执行上下文的方法 this==>赋值(调用函数的对象) 开始执行函数体代码 执行上下文创建和初始化的过程 全局: 在全局代码执行前最先创建一个全局执行上下文(window) 收集一些全局变量, 并初始化 将这些变量设置为window的属性 函数: 在调用函数时, 在执行函数体之前先创建一个函数执行上下文 收集一些局部变量, 并初始化 将这些变量设置为执行上下文的属性 整个过程中产生了几个执行上下文? n+1原则 n代表调用多少次函数，1代表全局 生命周期 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡 函数 : 调用函数时产生, 函数执行完时死亡 变量提升与函数提升（执行上下文，预处理的结果） 变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined) 函数提升: 在函数定义语句之前, 就执行该函数（原则上是先定义，后调用） 在函数提升和变量提升的同时，函数提升的优先级高于变量提升，在js引擎渲染代码之时， 函数会被提升到最顶部，然后变量提升。 执行上下文理解题目： /- 测试题1: 先执行变量提升, 再执行函数提升 -/ function a() {} var a console.log(typeof a) // 'function' /- 测试题2: -/ if (!(b in window)) { var b = 1 } console.log(b) // undefined 因为if中的代码未执行 /- 测试题3: -/ var c = 1 function c(c) { console.log(c) var c = 3 } c(2) // 报错 第三题的代码相当于 var c ; function c(c) { console.log(c) var c = 3 } c=1; c(2) // 报错 1:所有的声明都会提升到作用域的最顶上去。 2:同一个变量只会声明一次，其他的会被忽略掉。 3:函数声明的优先级高于变量申明的优先级，并且函数声明和函数定义的部分一起被提升。 作用域与作用域链 理解: 作用域: 一块代码区域, 在编码时就确定了, 不会再变化 作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量 理解 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外) 查找变量时就是沿着作用域链来查找的 查找一个变量的查找规则 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入外层 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入外层 再次执行的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常 分类: 全局 函数 js没有块作用域(在ES6之前，let块级作用域) 作用 作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突 作用域链: 查找变量 区别作用域与执行上下文 作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了 执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失 联系: 执行上下文环境是在对应的作用域中的 闭包 产生闭包的条件? 函数嵌套 内部函数引用了外部函数的数据(变量/函数) 外部函数调用，内部函数执行定义，不用调用就能产生 闭包到底是什么? 使用chrome调试查看 理解一: 闭包是嵌套的内部函数(绝大部分人) 理解二: 内部函数+包含被引用变量(函数)的对象(极少数人) 注意: 闭包存在于嵌套的内部函数中 以上两个例子产生了闭包，但是无实际意义 常见的闭包 闭包作用: 使用函数内部的变量在函数执行完后, 可能仍然存活在内存中(可能延长了局部变量的生命周期) 可以让函数外部可以操作(读写)到函数内部的数据(变量/函数) 问题: 函数执行完后, 函数内部声明的局部变量是否还存在? 一般是不存在, 存在于闭包中的变量才可能存在 在函数外部能直接访问函数内部的局部变量吗? 不能, 但我们可以通过闭包让外部操作它 闭包生命周期 闭包应用: 模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为 循环遍历加监听 JS框架(jQuery)大量使用了闭包 JS模块化：（核心就是使用闭包） 具有特定功能的js文件 将所有的数据和功能都封装在一个函数内部(私有的) 只向外暴露一个包信n个方法的对象或函数 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能第一种： 第二种： （经常用的模块化） 缺点: 变量占用内存的时间可能会过长 可能导致内存泄露 解决: 及时释放 : f = null; //让内部函数对象成为垃圾对象 内存溢出与内存泄露 内存溢出 一种程序运行出现的错误 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误 内存泄露 占用的内存没有及时释放 内存泄露积累多了就容易导致内存溢出 常见的内存泄露: 意外的全局变量 没有及时清理的计时器或回调函数 闭包 面试题 终极面试题（难道较大） Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 08:46:17 "},"src/JavaScript/high/03_object.html":{"url":"src/JavaScript/high/03_object.html","title":"对象高级","keywords":"","body":"对象的创建模式 Object构造函数模式 对象字面量模式 工厂函数（不用） 构造函数模式 构造函数+原型的组合模式 继承模式 原型链继承 : 得到方法 方式1: 原型链继承 1. 套路 1. 定义父类型构造函数 2. 给父类型的原型添加方法 3. 定义子类型的构造函数 4. 创建父类型的对象赋值给子类型的原型 5. 将子类型原型的构造属性设置为子类型 6. 给子类型原型添加方法 7. 创建子类型的对象: 可以调用父类型的方法 2. 关键 1. 子类型的原型为父类型的一个实例对象 借用构造函数 : 得到属性 方式2: 借用构造函数继承(假的) 1. 套路: 1. 定义父类型构造函数 2. 定义子类型构造函数 3. 在子类型构造函数中调用父类型构造 2. 关键: 1. 在子类型构造函数中通用super()调用父类型构造函数 组合 方式3:原型链+借用构造函数的组合继承 1. 利用原型链实现对父类型对象的方法继承 2. 利用call()借用父类型构建函数初始化相同属性 new一个对象背后做了些什么? 创建一个空对象 给对象设置proto, 值为构造函数对象的prototype属性值 this.proto = Fn.prototype 执行构造函数体(给对象添加属性/方法) Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 09:17:32 "},"src/JavaScript/high/04_thread.html":{"url":"src/JavaScript/high/04_thread.html","title":"线程机制与事件机制","keywords":"","body":"线程与进程 进程: 程序的一次执行, 它占有一片独有的内存空间 可以通过windows任务管理器查看进程 多进程运行: 一应用程序可以同时启动多个实例运行 线程: 是进程内的一个独立执行单元 是程序执行的一个完整流程 是CPU的最小的调度单元 多线程: 在一个进程内, 同时有多个线程运行 关系 一个进程至少有一个线程(主) 程序是在某个进程中的某个线程执行的 浏览器内核模块组成 主线程 js引擎模块 : 负责js程序的编译与运行 html,css文档解析模块 : 负责页面文本的解析 DOM/CSS模块 : 负责dom/css在内存中的相关处理 布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象) 分线程 定时器模块 : 负责定时器的管理 DOM事件模块 : 负责事件的管理 网络请求模块 : 负责Ajax请求 js线程 js是单线程执行的(回调函数也是在主线程) H5提出了实现多线程的方案: Web Workers 只能是主线程更新界面 定时器问题: 定时器并不真正完全定时 如果在主线程执行了一个长时间的操作, 可能导致延时才处理 事件处理机制(图) 代码分类 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码 回调执行代码: 处理回调逻辑 js引擎执行代码的基本流程: 初始化代码===>回调代码 模型的2个重要组成部分: 事件管理模块 回调队列 模型的运转流程 执行初始化代码, 将事件回调函数交给对应模块管理 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行 H5 Web Workers 可以让js在分线程执行 Workervar worker = new Worker('worker.js'); worker.onMessage = function(event){event.data} : 用来接收另一个线程发送过来的数据的回调 worker.postMessage(data1) : 向另一个线程发送数据 问题: worker内代码不能操作DOM更新UI 不是每个浏览器都支持这个新特性 不能跨域加载JS H5 Web Workers(多线程) Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 09:37:07 "},"src/JavaScript/JSON/":{"url":"src/JavaScript/JSON/","title":"JSON","keywords":"","body":" JSON JS中的对象只有JS自己认识，其他的语言都不认识 JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别， 并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互 JavaScript Object Notation JS对象表示法 JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号 其他的和JS语法一致 JSON格式分类： 对象 {} 数组 [] JSON中允许的值： 字符串 数值 布尔值 null 对象 数组 //创建一个对象 var obj = '{\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"}'; var arr = '[1,2,3,\"hello\",true]'; var obj2 = '{\"arr\":[1,2,3]}'; var arr2 ='[{\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"},{\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"}]'; 将JSON字符串转换为JS中的对象 在JS中，为我们提供了一个工具类，就叫JSON 这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON json --> js对象 JSON.parse() - 可以将以JSON字符串转换为js对象 - 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回 JS对象 ---> JSON JSON.stringify() - 可以将一个JS对象转换为JSON字符串 - 需要一个js对象作为参数，会返回一个JSON字符串 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 10:06:42 "},"src/ES6/":{"url":"src/ES6/","title":"ES6 ✔","keywords":"","body":"ES6 目录 目录 let const 解构赋值 模版字符串 简化对象写法 箭头函数 点点点运算符 形参默认值 Promise symbol iterator generator async class module Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 11:58:31 "},"src/ES6/01_let.html":{"url":"src/ES6/01_let.html","title":"let","keywords":"","body":" 作用: 与var类似, 用于声明一个变量 特点: 在块作用域内有效 不能重复声明 不会预处理, 不存在提升 应用: 循环遍历加监听 使用let取代var是趋势 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 10:43:18 "},"src/ES6/02_const.html":{"url":"src/ES6/02_const.html","title":"const","keywords":"","body":" 作用: 定义一个常量 特点: 不能修改 其它特点同let 应用: 保存不用改变的数据 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 10:44:17 "},"src/ES6/03_deconstruction.html":{"url":"src/ES6/03_deconstruction.html","title":"解构赋值","keywords":"","body":" 理解: 从对象或数组中提取数据, 并赋值给变量(多个) 对象的解构赋值 let {n, a} = {n:'tom', a:12} 数组的解构赋值 let [a,b] = [1, 'atguigu']; 用途 给多个形参赋值 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 10:45:25 "},"src/ES6/04_string.html":{"url":"src/ES6/04_string.html","title":"模版字符串","keywords":"","body":" 模板字符串 : 简化字符串的拼接 模板字符串必须用 `` 包含 变化的部分使用${xxx}定义 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 10:48:35 "},"src/ES6/05_obj.html":{"url":"src/ES6/05_obj.html","title":"简化对象写法","keywords":"","body":"简化的对象写法 省略同名的属性值 省略方法的function 例如:let x = 1; let y = 2; let point = { x, y, setX (x) {this.x = x} }; Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 10:49:48 "},"src/ES6/06_func.html":{"url":"src/ES6/06_func.html","title":"箭头函数","keywords":"","body":" 作用: 定义匿名函数 基本语法: 没有参数: () => console.log('xxxx') 一个参数: i => i+2 大于一个参数: (i,j) => i+j 函数体不用大括号: 默认返回结果 函数体如果有多个语句, 需要用{}包围，若有需要返回的内容，需要手动返回 使用场景: 多用来定义回调函数 箭头函数的特点： 简洁 箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this 扩展理解： 箭头函数的this看外层的是否有函数， 如果有，外层函数的this就是内部箭头函数的this， 如果没有，则this是window。 箭头函数的表达形式： 箭头函数没有自己的this Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 10:53:50 "},"src/ES6/07_dian.html":{"url":"src/ES6/07_dian.html","title":"点点点运算符","keywords":"","body":" rest(可变)参数用来取代arguments 但比arguments灵活,只能是最后部分形参参数 function add(...values) { let sum = 0; for(value of values) { sum += value; } return sum; } 扩展运算符 let arr1 = [1,3,5]; let arr2 = [2,...arr1,6]; arr2.push(...arr1); Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 10:58:05 "},"src/ES6/08_xc.html":{"url":"src/ES6/08_xc.html","title":"形参默认值","keywords":"","body":"形参的默认值----当不传入参数的时候默认使用形参里的默认值 function Point(x = 1,y = 2) { this.x = x; this.y = y; } Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 11:00:29 "},"src/ES6/09_promise.html":{"url":"src/ES6/09_promise.html","title":"Promise","keywords":"","body":" 理解: Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作) 有了promise对象, 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称'回调地狱') ES6的Promise是一个构造函数, 用来生成promise实例 使用promise基本步骤(2步): 创建promise对象let promise = new Promise((resolve, reject) => { //初始化promise状态为 pending //执行异步操作 if(异步操作成功) { resolve(value);//修改promise的状态为fullfilled } else { reject(errMsg);//修改promise的状态为rejected } }) 调用promise的then()promise.then(function( result => console.log(result), errorMsg => alert(errorMsg) )) promise对象的3个状态 pending: 初始化状态 fullfilled: 成功状态 rejected: 失败状态 应用: 使用promise实现超时处理 使用promise封装处理ajax请求 let request = new XMLHttpRequest(); request.onreadystatechange = function () { } request.responseType = 'json'; request.open(\"GET\", url); request.send(); 基本应用 结合ajax发送异步请求实例 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 11:05:16 "},"src/ES6/10_symbol.html":{"url":"src/ES6/10_symbol.html","title":"symbol","keywords":"","body":" 前言：ES5中对象的属性名都是字符串，容易造成重名，污染环境 Symbol： 概念：ES6中的添加了一种原始数据类型symbol(已有的原始数据类型：String, Number, boolean, null, undefined, 对象) 特点： Symbol属性对应的值是唯一的，解决命名冲突问题 Symbol值不能与其他数据进行计算，包括同字符串拼串 for in, for of遍历时不会遍历symbol属性。 使用： 调用Symbol函数得到symbol值let symbol = Symbol(); let obj = {}; obj[symbol] = 'hello'; 传参标识let symbol = Symbol('one'); let symbol2 = Symbol('two'); console.log(symbol);// Symbol('one') console.log(symbol2);// Symbol('two') 内置Symbol值 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。 Symbol.iterator 对象的Symbol.iterator属性，指向该对象的默认遍历器方法(后边讲) Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 11:19:12 "},"src/ES6/11_iterator.html":{"url":"src/ES6/11_iterator.html","title":"iterator","keywords":"","body":" 概念： iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制 作用： 为各种数据结构，提供一个统一的, 简便的访问接口； 使得数据结构的成员能够按某种次序排列 ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。 工作原理： 创建一个指针对象，指向数据结构的起始位置。 第一次调用next方法，指针自动指向数据结构的第一个成员 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员 每调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值,done: 布尔值} value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。 当遍历结束的时候返回的value值是undefined，done值为false 原生具备iterator接口的数据(可用for of遍历) Array arguments set容器 map容器 String 。。。 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 11:21:45 "},"src/ES6/12_generator.html":{"url":"src/ES6/12_generator.html","title":"generator","keywords":"","body":"Generator函数 概念： ES6提供的解决异步编程的方案之一 Generator函数是一个状态机，内部封装了不同状态的数据， 用来生成遍历器对象 可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果 特点： function 与函数名之间有一个星号 内部用yield表达式来定义不同的状态 例如：function* generatorExample(){ let result = yield 'hello'; // 状态值为hello yield 'generator'; // 状态值为generator } generator函数返回的是指针对象(接11章节里iterator)，而不会执行函数内部逻辑 调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true} 再次调用next方法会从上一次停止时的yield处开始，直到最后 yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 11:25:20 "},"src/ES6/13_async.html":{"url":"src/ES6/13_async.html","title":"async","keywords":"","body":" async函数(源自ES2017) 概念： 真正意义上去解决异步回调的问题，同步流程表达异步操作 本质： Generator的语法糖 语法： async function foo(){ await 异步操作; await 异步操作； } 特点： 不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行 返回的总是Promise对象，可以用then方法进行下一步操作 async取代Generator函数的星号*，await取代Generator的yield 语意上更为明确，使用简单，经临床验证，暂时没有任何副作用 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 11:30:07 "},"src/ES6/14_class.html":{"url":"src/ES6/14_class.html","title":"class","keywords":"","body":" 通过class定义类/实现类的继承 在类中通过constructor定义构造方法 通过new来创建类的实例 通过extends来实现类的继承 通过super调用父类的构造方法 重写从父类中继承的一般方法 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 11:32:47 "},"src/ES6/15_module.html":{"url":"src/ES6/15_module.html","title":"module","keywords":"","body":" 模块化的理解 什么是模块? 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起 块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信 一个模块的组成 数据--->内部的属性 操作数据的行为--->内部的函数 模块化 编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目 模块化的进化过程 全局function模式 : 编码: 全局变量/函数 问题: 污染全局命名空间, 容易引起命名冲突/数据不安全 namespace模式 : 编码: 将数据/行为封装到对象中 解决: 命名冲突(减少了全局变量) 问题: 数据不安全(外部可以直接修改模块内部的数据) IIFE模式/增强 IIFE : 立即调用函数表达式--->匿名函数自调用 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口 引入依赖: 通过函数形参来引入依赖模块 (function(window, module2){ var data = 'hahah' function foo() { module2.xxx() console.log('foo()'+data) } function bar() { console.log('bar()'+data) } window.module = {foo} })(window, module2) 模块化规范 CommonJS Node.js : 服务器端 Browserify : 浏览器端 也称为js的打包工具 基本语法: 定义暴露模块 : exportsexports.xxx = value module.exports = value 引入模块 : requirevar module = require('模块名/模块相对路径') 引入模块发生在什么时候? Node : 运行时, 动态同步引入 Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了), 运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块 AMD : 浏览器端 require.js 基本语法 定义暴露模块: define([依赖模块名], function(){return 模块对象}) 引入模块: require(['模块1', '模块2', '模块3'], function(m1, m2){//使用模块对象}) 配置: require.config({ //基本路径 baseUrl : 'js/', //标识名称与路径的映射 paths : { '模块1' : 'modules/模块1', '模块2' : 'modules/模块2', 'angular' : 'libs/angular', 'angular-messages' : 'libs/angular-messages' }, //非AMD的模块 shim : { 'angular' : { exports : 'angular' }, 'angular-messages' : { exports : 'angular-messages', deps : ['angular'] } } }) CMD : 浏览器端 sea.js 基本语法 定义暴露模块: define(function(require, module, exports){ 通过require引入依赖模块 通过module/exports来暴露模块 exports.xxx = value }) 使用模块seajs.use(['模块1', '模块2']) ES6 ES6内置了模块化的实现 基本语法 定义暴露模块 : export 暴露一个对象: export default 对象 暴露多个: export var xxx = value1 export let yyy = value2 var xxx = value1 let yyy = value2 export {xxx, yyy} 引入使用模块 : import default模块:（默认暴露，暴露什么就接收什么，一般只要一个变量去接收整个对象）import xxx from '模块路径/模块名' 其它模块（普通暴露引入时，必须采用对象的解构赋值的形式去接收）import {xxx, yyy} from '模块路径/模块名' import * as module1 from '模块路径/模块名' 问题: 所有浏览器还不能直接识别ES6模块化的语法 解决: 使用Babel将ES6--->ES5(使用了CommonJS) ----浏览器还不能直接支行 使用Browserify--->打包处理----浏览器可以运行 模块化进化史教程 全局function模式 module1.js //数据 let data = 'hahah' //操作数据的函数 function foo() { console.log(`foo() ${data}`) } function bar() { console.log(`bar() ${data}`) } module2.js let data2 = 'other data'; function foo() { //与另一个模块中的函数冲突了 console.log(`foo() ${data2}`) } test1.html let data = \"修改后的数据\" foo() bar() 说明: 全局函数模式: 将不同的功能封装成不同的全局函数 问题: Global被污染了, 很容易引起命名冲突 namespace模式 module1.jslet myModule = { data: 'hahah', foo() { console.log(`foo() ${this.data}`) }, bar() { console.log(`bar() ${this.data}`) } } module2.jslet myModule2 = { data: 'hahah2222', foo() { console.log(`foo() ${this.data}`) }, bar() { console.log(`bar() ${this.data}`) } } test2.html myModule.foo() myModule.bar() myModule2.foo() myModule2.bar() myModule.data = 'other data' //能直接修改模块内部的数据 myModule.foo() 说明 namespace模式: 简单对象封装 作用: 减少了全局变量 问题: 不安全 IIFE模式 module3.js (function (window) { //数据 let data = 'hahah' //操作数据的函数 function foo() { //用于暴露有函数 console.log(`foo() ${data}`) } function bar() {//用于暴露有函数 console.log(`bar() ${data}`) otherFun() //内部调用 } function otherFun() { //内部私有的函数 console.log('otherFun()') } //暴露行为 window.myModule = {foo, bar} })(window) test3.html myModule.foo() myModule.bar() //myModule.otherFun() //myModule.otherFun is not a function console.log(myModule.data) //undefined 不能访问模块内部数据 myModule.data = 'xxxx' //不是修改的模块内部的data myModule.foo() //没有改变 说明: IIFE模式: 匿名函数自调用(闭包) IIFE : immediately-invoked function expression(立即调用函数表达式) 作用: 数据是私有的, 外部只能通过暴露的方法操作 问题: 如果当前这个模块依赖另一个模块怎么办? IIFE模式增强 引入jquery到项目中 module4.js (function (window, $) { //数据 let data = 'hahah' //操作数据的函数 function foo() { //用于暴露有函数 console.log(`foo() ${data}`) $('body').css('background', 'red') } function bar() {//用于暴露有函数 console.log(`bar() ${data}`) otherFun() //内部调用 } function otherFun() { //内部私有的函数 console.log('otherFun()') } //暴露行为 window.myModule = {foo, bar} })(window, jQuery) test4.html myModule.foo() 说明 IIFE模式增强 : 引入依赖 这就是现代模块实现的基石 页面加载多个js的问题 页面: 说明 一个页面需要引入多个js文件 问题: 请求过多 依赖模糊 难以维护 这些问题可以通过现代模块化编码和项目构建来解决 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-19 11:48:44 "},"src/GitBook/":{"url":"src/GitBook/","title":"GitBook","keywords":"","body":"GitBook 基本命令 创建书籍 npm install gitbook-cli -g //安装GitBook gitbook install // 下载依赖 gitbook init //初始化书籍目录 gitbook serve //编译书籍 可以用浏览器打开 http://127.0.0.1:4000 查看书籍的效果 gitbook build //打包书籍 发布到 GitHub Pages 构建书籍: 首先，使用 gitbook build 将书籍内容输出到默认目录，也就是当前目录下的 _book 目录。gitbook build 创建 gh-pages 分支: 执行如下命令来创建分支，并且删除不需要的文件：git checkout --orphan gh-pages git rm --cached -r . git clean -df rm -rf *~ 现在，目录下应该只剩下 _book 目录了，首先，忽略一些文件： echo \"*~\" > .gitignore echo \"_book\" >> .gitignore git add .gitignore git commit -m \"Ignore some files\" 然后，加入 _book 下的内容到分支中： cp -r _book/* . git add . git commit -m \"Publish book\" 上传书籍内容到 GitHub git push -u origin gh-pages 总结 参考文档：GitBook 简明教程 Copyright © WTxiaomage 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-27 20:18:01 "}}